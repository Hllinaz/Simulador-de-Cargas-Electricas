/* autogenerated by Processing revision 1293 on 2024-10-26 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import org.apache.commons.collections4.bag.*;
import org.apache.commons.collections4.bidimap.*;
import org.apache.commons.collections4.collection.*;
import org.apache.commons.collections4.*;
import org.apache.commons.collections4.functors.*;
import org.apache.commons.collections4.iterators.*;
import org.apache.commons.collections4.list.*;
import org.apache.commons.collections4.map.*;
import org.apache.commons.collections4.multimap.*;
import org.apache.commons.collections4.multiset.*;
import org.apache.commons.collections4.queue.*;
import org.apache.commons.collections4.sequence.*;
import org.apache.commons.collections4.set.*;
import org.apache.commons.collections4.trie.*;
import org.apache.commons.collections4.comparators.*;
import org.apache.commons.collections4.keyvalue.*;
import org.apache.commons.collections4.properties.*;
import org.apache.commons.collections4.splitmap.*;
import org.apache.commons.collections4.trie.analyzer.*;
import org.apache.commons.compress.*;
import org.apache.commons.compress.archivers.*;
import org.apache.commons.compress.archivers.ar.*;
import org.apache.commons.compress.archivers.arj.*;
import org.apache.commons.compress.archivers.cpio.*;
import org.apache.commons.compress.archivers.dump.*;
import org.apache.commons.compress.archivers.examples.*;
import org.apache.commons.compress.archivers.jar.*;
import org.apache.commons.compress.archivers.sevenz.*;
import org.apache.commons.compress.archivers.tar.*;
import org.apache.commons.compress.archivers.zip.*;
import org.apache.commons.compress.changes.*;
import org.apache.commons.compress.compressors.*;
import org.apache.commons.compress.compressors.brotli.*;
import org.apache.commons.compress.compressors.bzip2.*;
import org.apache.commons.compress.compressors.deflate.*;
import org.apache.commons.compress.compressors.deflate64.*;
import org.apache.commons.compress.compressors.gzip.*;
import org.apache.commons.compress.compressors.lz4.*;
import org.apache.commons.compress.compressors.lz77support.*;
import org.apache.commons.compress.compressors.lzma.*;
import org.apache.commons.compress.compressors.lzw.*;
import org.apache.commons.compress.compressors.pack200.*;
import org.apache.commons.compress.compressors.snappy.*;
import org.apache.commons.compress.compressors.xz.*;
import org.apache.commons.compress.compressors.z.*;
import org.apache.commons.compress.compressors.zstandard.*;
import org.apache.commons.compress.harmony.archive.internal.nls.*;
import org.apache.commons.compress.harmony.pack200.*;
import org.apache.commons.compress.harmony.*;
import org.apache.commons.compress.harmony.unpack200.*;
import org.apache.commons.compress.harmony.unpack200.bytecode.*;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.*;
import org.apache.commons.compress.java.util.jar.*;
import org.apache.commons.compress.parallel.*;
import org.apache.commons.compress.utils.*;
import org.apache.commons.io.*;
import org.apache.commons.io.build.*;
import org.apache.commons.io.channels.*;
import org.apache.commons.io.charset.*;
import org.apache.commons.io.comparator.*;
import org.apache.commons.io.file.*;
import org.apache.commons.io.file.attribute.*;
import org.apache.commons.io.file.spi.*;
import org.apache.commons.io.filefilter.*;
import org.apache.commons.io.function.*;
import org.apache.commons.io.input.*;
import org.apache.commons.io.input.buffer.*;
import org.apache.commons.io.monitor.*;
import org.apache.commons.io.output.*;
import org.apache.commons.io.serialization.*;
import org.eclipse.collections.impl.map.immutable.primitive.*;
import org.eclipse.collections.impl.map.immutable.*;
import org.eclipse.collections.impl.map.mutable.primitive.*;
import org.eclipse.collections.impl.map.mutable.*;
import org.eclipse.collections.impl.map.primitive.*;
import org.eclipse.collections.impl.map.sorted.mutable.*;
import org.eclipse.collections.impl.map.sorted.immutable.*;
import org.eclipse.collections.impl.map.fixed.*;
import org.eclipse.collections.impl.map.strategy.immutable.*;
import org.eclipse.collections.impl.map.strategy.mutable.*;
import org.eclipse.collections.impl.map.ordered.mutable.*;
import org.eclipse.collections.impl.map.*;
import org.eclipse.collections.impl.factory.primitive.*;
import org.eclipse.collections.impl.factory.*;
import org.eclipse.collections.impl.lazy.primitive.*;
import org.eclipse.collections.impl.lazy.parallel.bag.*;
import org.eclipse.collections.impl.lazy.parallel.set.sorted.*;
import org.eclipse.collections.impl.lazy.parallel.set.*;
import org.eclipse.collections.impl.lazy.parallel.list.*;
import org.eclipse.collections.impl.lazy.parallel.*;
import org.eclipse.collections.impl.lazy.iterator.*;
import org.eclipse.collections.impl.lazy.*;
import org.eclipse.collections.impl.bag.mutable.primitive.*;
import org.eclipse.collections.impl.bag.mutable.*;
import org.eclipse.collections.impl.bag.immutable.primitive.*;
import org.eclipse.collections.impl.bag.immutable.*;
import org.eclipse.collections.impl.bag.sorted.mutable.*;
import org.eclipse.collections.impl.bag.sorted.immutable.*;
import org.eclipse.collections.impl.bag.strategy.mutable.*;
import org.eclipse.collections.impl.bag.*;
import org.eclipse.collections.impl.primitive.*;
import org.eclipse.collections.impl.multimap.set.strategy.*;
import org.eclipse.collections.impl.multimap.set.sorted.*;
import org.eclipse.collections.impl.multimap.set.*;
import org.eclipse.collections.impl.multimap.list.*;
import org.eclipse.collections.impl.multimap.bag.sorted.mutable.*;
import org.eclipse.collections.impl.multimap.bag.sorted.immutable.*;
import org.eclipse.collections.impl.multimap.bag.sorted.*;
import org.eclipse.collections.impl.multimap.bag.strategy.*;
import org.eclipse.collections.impl.multimap.bag.*;
import org.eclipse.collections.impl.multimap.*;
import org.eclipse.collections.impl.parallel.*;
import org.eclipse.collections.impl.block.procedure.primitive.*;
import org.eclipse.collections.impl.block.procedure.checked.primitive.*;
import org.eclipse.collections.impl.block.procedure.checked.*;
import org.eclipse.collections.impl.block.procedure.*;
import org.eclipse.collections.impl.block.function.checked.*;
import org.eclipse.collections.impl.block.function.primitive.*;
import org.eclipse.collections.impl.block.function.*;
import org.eclipse.collections.impl.block.factory.primitive.*;
import org.eclipse.collections.impl.block.factory.*;
import org.eclipse.collections.impl.block.predicate.checked.*;
import org.eclipse.collections.impl.block.predicate.primitive.*;
import org.eclipse.collections.impl.block.predicate.*;
import org.eclipse.collections.impl.block.comparator.primitive.*;
import org.eclipse.collections.impl.block.comparator.*;
import org.eclipse.collections.impl.list.mutable.primitive.*;
import org.eclipse.collections.impl.list.mutable.*;
import org.eclipse.collections.impl.list.fixed.*;
import org.eclipse.collections.impl.list.immutable.primitive.*;
import org.eclipse.collections.impl.list.immutable.*;
import org.eclipse.collections.impl.list.primitive.*;
import org.eclipse.collections.impl.list.*;
import org.eclipse.collections.impl.collection.mutable.primitive.*;
import org.eclipse.collections.impl.collection.mutable.*;
import org.eclipse.collections.impl.collection.immutable.*;
import org.eclipse.collections.impl.collection.*;
import org.eclipse.collections.impl.partition.list.*;
import org.eclipse.collections.impl.partition.set.sorted.*;
import org.eclipse.collections.impl.partition.set.strategy.*;
import org.eclipse.collections.impl.partition.set.*;
import org.eclipse.collections.impl.partition.stack.*;
import org.eclipse.collections.impl.partition.bag.sorted.*;
import org.eclipse.collections.impl.partition.bag.*;
import org.eclipse.collections.impl.stack.primitive.*;
import org.eclipse.collections.impl.stack.mutable.primitive.*;
import org.eclipse.collections.impl.stack.mutable.*;
import org.eclipse.collections.impl.stack.immutable.primitive.*;
import org.eclipse.collections.impl.stack.immutable.*;
import org.eclipse.collections.impl.set.mutable.primitive.*;
import org.eclipse.collections.impl.set.mutable.*;
import org.eclipse.collections.impl.set.primitive.*;
import org.eclipse.collections.impl.set.immutable.primitive.*;
import org.eclipse.collections.impl.set.immutable.*;
import org.eclipse.collections.impl.set.strategy.immutable.*;
import org.eclipse.collections.impl.set.strategy.mutable.*;
import org.eclipse.collections.impl.set.fixed.*;
import org.eclipse.collections.impl.set.sorted.immutable.*;
import org.eclipse.collections.impl.set.sorted.mutable.*;
import org.eclipse.collections.impl.set.*;
import org.eclipse.collections.impl.string.immutable.*;
import org.eclipse.collections.impl.tuple.primitive.*;
import org.eclipse.collections.impl.tuple.*;
import org.eclipse.collections.impl.utility.internal.primitive.*;
import org.eclipse.collections.impl.utility.internal.*;
import org.eclipse.collections.impl.utility.primitive.*;
import org.eclipse.collections.impl.utility.*;
import org.eclipse.collections.impl.bimap.mutable.*;
import org.eclipse.collections.impl.bimap.immutable.*;
import org.eclipse.collections.impl.bimap.*;
import org.eclipse.collections.impl.iterator.*;
import org.eclipse.collections.impl.stream.primitive.*;
import org.eclipse.collections.impl.stream.*;
import org.eclipse.collections.impl.collector.*;
import org.eclipse.collections.impl.*;
import org.eclipse.collections.api.iterator.*;
import org.eclipse.collections.api.block.procedure.primitive.*;
import org.eclipse.collections.api.block.procedure.*;
import org.eclipse.collections.api.block.predicate.primitive.*;
import org.eclipse.collections.api.block.predicate.*;
import org.eclipse.collections.api.block.function.primitive.*;
import org.eclipse.collections.api.block.function.*;
import org.eclipse.collections.api.block.comparator.primitive.*;
import org.eclipse.collections.api.block.comparator.*;
import org.eclipse.collections.api.block.factory.*;
import org.eclipse.collections.api.block.*;
import org.eclipse.collections.api.collection.primitive.*;
import org.eclipse.collections.api.collection.*;
import org.eclipse.collections.api.list.primitive.*;
import org.eclipse.collections.api.list.*;
import org.eclipse.collections.api.ordered.primitive.*;
import org.eclipse.collections.api.ordered.*;
import org.eclipse.collections.api.set.primitive.*;
import org.eclipse.collections.api.set.sorted.*;
import org.eclipse.collections.api.set.*;
import org.eclipse.collections.api.bag.primitive.*;
import org.eclipse.collections.api.bag.sorted.*;
import org.eclipse.collections.api.bag.*;
import org.eclipse.collections.api.partition.list.*;
import org.eclipse.collections.api.partition.ordered.*;
import org.eclipse.collections.api.partition.set.sorted.*;
import org.eclipse.collections.api.partition.set.*;
import org.eclipse.collections.api.partition.bag.sorted.*;
import org.eclipse.collections.api.partition.bag.*;
import org.eclipse.collections.api.partition.stack.*;
import org.eclipse.collections.api.partition.*;
import org.eclipse.collections.api.map.sorted.*;
import org.eclipse.collections.api.map.primitive.*;
import org.eclipse.collections.api.map.*;
import org.eclipse.collections.api.bimap.*;
import org.eclipse.collections.api.multimap.list.*;
import org.eclipse.collections.api.multimap.ordered.*;
import org.eclipse.collections.api.multimap.set.*;
import org.eclipse.collections.api.multimap.sortedset.*;
import org.eclipse.collections.api.multimap.bag.*;
import org.eclipse.collections.api.multimap.sortedbag.*;
import org.eclipse.collections.api.multimap.*;
import org.eclipse.collections.api.tuple.primitive.*;
import org.eclipse.collections.api.tuple.*;
import org.eclipse.collections.api.annotation.*;
import org.eclipse.collections.api.stack.primitive.*;
import org.eclipse.collections.api.stack.*;
import org.eclipse.collections.api.factory.set.primitive.*;
import org.eclipse.collections.api.factory.set.strategy.*;
import org.eclipse.collections.api.factory.set.sorted.*;
import org.eclipse.collections.api.factory.set.*;
import org.eclipse.collections.api.factory.list.primitive.*;
import org.eclipse.collections.api.factory.list.*;
import org.eclipse.collections.api.factory.primitive.*;
import org.eclipse.collections.api.factory.map.primitive.*;
import org.eclipse.collections.api.factory.map.sorted.*;
import org.eclipse.collections.api.factory.map.strategy.*;
import org.eclipse.collections.api.factory.map.*;
import org.eclipse.collections.api.factory.stack.primitive.*;
import org.eclipse.collections.api.factory.stack.*;
import org.eclipse.collections.api.factory.bag.primitive.*;
import org.eclipse.collections.api.factory.bag.sorted.*;
import org.eclipse.collections.api.factory.bag.strategy.*;
import org.eclipse.collections.api.factory.bag.*;
import org.eclipse.collections.api.factory.bimap.*;
import org.eclipse.collections.api.factory.*;
import org.eclipse.collections.api.*;
import org.apache.logging.log4j.*;
import org.apache.logging.log4j.internal.*;
import org.apache.logging.log4j.message.*;
import org.apache.logging.log4j.simple.*;
import org.apache.logging.log4j.spi.*;
import org.apache.logging.log4j.status.*;
import org.apache.logging.log4j.util.*;
import org.apache.logging.log4j.core.*;
import org.apache.logging.log4j.core.appender.*;
import org.apache.logging.log4j.core.appender.db.*;
import org.apache.logging.log4j.core.appender.db.jdbc.*;
import org.apache.logging.log4j.core.appender.mom.*;
import org.apache.logging.log4j.core.appender.mom.jeromq.*;
import org.apache.logging.log4j.core.appender.mom.kafka.*;
import org.apache.logging.log4j.core.appender.nosql.*;
import org.apache.logging.log4j.core.appender.rewrite.*;
import org.apache.logging.log4j.core.appender.rolling.*;
import org.apache.logging.log4j.core.appender.rolling.action.*;
import org.apache.logging.log4j.core.appender.routing.*;
import org.apache.logging.log4j.core.async.*;
import org.apache.logging.log4j.core.config.*;
import org.apache.logging.log4j.core.config.arbiters.*;
import org.apache.logging.log4j.core.config.builder.api.*;
import org.apache.logging.log4j.core.config.builder.impl.*;
import org.apache.logging.log4j.core.config.composite.*;
import org.apache.logging.log4j.core.config.json.*;
import org.apache.logging.log4j.core.config.plugins.*;
import org.apache.logging.log4j.core.config.plugins.convert.*;
import org.apache.logging.log4j.core.config.plugins.processor.*;
import org.apache.logging.log4j.core.config.plugins.util.*;
import org.apache.logging.log4j.core.config.plugins.validation.*;
import org.apache.logging.log4j.core.config.plugins.validation.constraints.*;
import org.apache.logging.log4j.core.config.plugins.validation.validators.*;
import org.apache.logging.log4j.core.config.plugins.visitors.*;
import org.apache.logging.log4j.core.config.properties.*;
import org.apache.logging.log4j.core.config.status.*;
import org.apache.logging.log4j.core.config.xml.*;
import org.apache.logging.log4j.core.config.yaml.*;
import org.apache.logging.log4j.core.filter.*;
import org.apache.logging.log4j.core.filter.mutable.*;
import org.apache.logging.log4j.core.impl.*;
import org.apache.logging.log4j.core.jackson.*;
import org.apache.logging.log4j.core.jmx.*;
import org.apache.logging.log4j.core.layout.*;
import org.apache.logging.log4j.core.layout.internal.*;
import org.apache.logging.log4j.core.lookup.*;
import org.apache.logging.log4j.core.message.*;
import org.apache.logging.log4j.core.net.*;
import org.apache.logging.log4j.core.net.ssl.*;
import org.apache.logging.log4j.core.osgi.*;
import org.apache.logging.log4j.core.parser.*;
import org.apache.logging.log4j.core.pattern.*;
import org.apache.logging.log4j.core.script.*;
import org.apache.logging.log4j.core.selector.*;
import org.apache.logging.log4j.core.time.*;
import org.apache.logging.log4j.core.time.internal.*;
import org.apache.logging.log4j.core.tools.*;
import org.apache.logging.log4j.core.tools.picocli.*;
import org.apache.logging.log4j.core.util.*;
import org.apache.logging.log4j.core.util.datetime.*;
import org.apache.logging.log4j.core.util.internal.*;
import org.apache.poi.*;
import org.apache.poi.common.*;
import org.apache.poi.common.usermodel.*;
import org.apache.poi.common.usermodel.fonts.*;
import org.apache.poi.ddf.*;
import org.apache.poi.extractor.*;
import org.apache.poi.hpsf.*;
import org.apache.poi.hpsf.extractor.*;
import org.apache.poi.hpsf.wellknown.*;
import org.apache.poi.hssf.*;
import org.apache.poi.hssf.eventmodel.*;
import org.apache.poi.hssf.eventusermodel.*;
import org.apache.poi.hssf.eventusermodel.dummyrecord.*;
import org.apache.poi.hssf.extractor.*;
import org.apache.poi.hssf.model.*;
import org.apache.poi.hssf.record.*;
import org.apache.poi.hssf.record.aggregates.*;
import org.apache.poi.hssf.record.cf.*;
import org.apache.poi.hssf.record.chart.*;
import org.apache.poi.hssf.record.common.*;
import org.apache.poi.hssf.record.cont.*;
import org.apache.poi.hssf.record.crypto.*;
import org.apache.poi.hssf.record.pivottable.*;
import org.apache.poi.hssf.usermodel.*;
import org.apache.poi.hssf.usermodel.helpers.*;
import org.apache.poi.hssf.util.*;
import org.apache.poi.poifs.common.*;
import org.apache.poi.poifs.crypt.*;
import org.apache.poi.poifs.crypt.agile.*;
import org.apache.poi.poifs.crypt.binaryrc4.*;
import org.apache.poi.poifs.crypt.cryptoapi.*;
import org.apache.poi.poifs.crypt.standard.*;
import org.apache.poi.poifs.crypt.xor.*;
import org.apache.poi.poifs.dev.*;
import org.apache.poi.poifs.eventfilesystem.*;
import org.apache.poi.poifs.filesystem.*;
import org.apache.poi.poifs.macros.*;
import org.apache.poi.poifs.nio.*;
import org.apache.poi.poifs.property.*;
import org.apache.poi.poifs.storage.*;
import org.apache.poi.sl.draw.*;
import org.apache.poi.sl.draw.geom.*;
import org.apache.poi.sl.extractor.*;
import org.apache.poi.sl.image.*;
import org.apache.poi.sl.usermodel.*;
import org.apache.poi.ss.*;
import org.apache.poi.ss.extractor.*;
import org.apache.poi.ss.format.*;
import org.apache.poi.ss.formula.*;
import org.apache.poi.ss.formula.atp.*;
import org.apache.poi.ss.formula.constant.*;
import org.apache.poi.ss.formula.eval.*;
import org.apache.poi.ss.formula.eval.forked.*;
import org.apache.poi.ss.formula.function.*;
import org.apache.poi.ss.formula.functions.*;
import org.apache.poi.ss.formula.ptg.*;
import org.apache.poi.ss.formula.udf.*;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.ss.usermodel.helpers.*;
import org.apache.poi.ss.util.*;
import org.apache.poi.ss.util.cellwalk.*;
import org.apache.poi.util.*;
import org.apache.poi.wp.usermodel.*;
import org.apache.poi.ooxml.*;
import org.apache.poi.ooxml.dev.*;
import org.apache.poi.ooxml.extractor.*;
import org.apache.poi.ooxml.util.*;
import org.apache.poi.openxml4j.exceptions.*;
import org.apache.poi.openxml4j.opc.*;
import org.apache.poi.openxml4j.opc.internal.*;
import org.apache.poi.openxml4j.opc.internal.marshallers.*;
import org.apache.poi.openxml4j.opc.internal.unmarshallers.*;
import org.apache.poi.openxml4j.util.*;
import org.apache.poi.poifs.crypt.dsig.*;
import org.apache.poi.poifs.crypt.dsig.facets.*;
import org.apache.poi.poifs.crypt.dsig.services.*;
import org.apache.poi.poifs.crypt.temp.*;
import org.apache.poi.xddf.usermodel.*;
import org.apache.poi.xddf.usermodel.chart.*;
import org.apache.poi.xddf.usermodel.text.*;
import org.apache.poi.xdgf.exceptions.*;
import org.apache.poi.xdgf.extractor.*;
import org.apache.poi.xdgf.geom.*;
import org.apache.poi.xdgf.usermodel.*;
import org.apache.poi.xdgf.usermodel.section.*;
import org.apache.poi.xdgf.usermodel.section.geometry.*;
import org.apache.poi.xdgf.usermodel.shape.*;
import org.apache.poi.xdgf.usermodel.shape.exceptions.*;
import org.apache.poi.xdgf.util.*;
import org.apache.poi.xdgf.xml.*;
import org.apache.poi.xslf.draw.*;
import org.apache.poi.xslf.draw.geom.*;
import org.apache.poi.xslf.extractor.*;
import org.apache.poi.xslf.model.*;
import org.apache.poi.xslf.usermodel.*;
import org.apache.poi.xslf.util.*;
import org.apache.poi.xssf.*;
import org.apache.poi.xssf.binary.*;
import org.apache.poi.xssf.eventusermodel.*;
import org.apache.poi.xssf.extractor.*;
import org.apache.poi.xssf.model.*;
import org.apache.poi.xssf.streaming.*;
import org.apache.poi.xssf.usermodel.*;
import org.apache.poi.xssf.usermodel.extensions.*;
import org.apache.poi.xssf.usermodel.helpers.*;
import org.apache.poi.xssf.util.*;
import org.apache.poi.xwpf.extractor.*;
import org.apache.poi.xwpf.model.*;
import org.apache.poi.xwpf.usermodel.*;
import com.microsoft.schemas.compatibility.*;
import com.microsoft.schemas.compatibility.impl.*;
import com.microsoft.schemas.office.drawing.x2008.diagram.*;
import com.microsoft.schemas.office.drawing.x2008.diagram.impl.*;
import com.microsoft.schemas.office.drawing.x2012.chart.*;
import com.microsoft.schemas.office.drawing.x2012.chart.impl.*;
import com.microsoft.schemas.office.drawing.x2014.chartex.*;
import com.microsoft.schemas.office.drawing.x2014.chartex.impl.*;
import com.microsoft.schemas.office.excel.*;
import com.microsoft.schemas.office.excel.impl.*;
import com.microsoft.schemas.office.office.*;
import com.microsoft.schemas.office.office.impl.*;
import com.microsoft.schemas.office.powerpoint.*;
import com.microsoft.schemas.office.powerpoint.impl.*;
import com.microsoft.schemas.office.spreadsheetml.x2018.threadedcomments.*;
import com.microsoft.schemas.office.spreadsheetml.x2018.threadedcomments.impl.*;
import com.microsoft.schemas.office.spreadsheetml.x2020.threadedcomments2.*;
import com.microsoft.schemas.office.spreadsheetml.x2020.threadedcomments2.impl.*;
import com.microsoft.schemas.office.visio.x2012.main.*;
import com.microsoft.schemas.office.visio.x2012.main.impl.*;
import com.microsoft.schemas.office.word.*;
import com.microsoft.schemas.office.word.impl.*;
import com.microsoft.schemas.office.word.x2012.wordml.*;
import com.microsoft.schemas.office.word.x2012.wordml.impl.*;
import com.microsoft.schemas.office.x2006.digsig.*;
import com.microsoft.schemas.office.x2006.digsig.impl.*;
import com.microsoft.schemas.vml.*;
import com.microsoft.schemas.vml.impl.*;
import org.apache.poi.schemas.ooxml.system.ooxml.*;
import org.apache.poi.schemas.vmldrawing.*;
import org.apache.poi.schemas.vmldrawing.impl.*;
import org.etsi.uri.x01903.v13.*;
import org.etsi.uri.x01903.v13.impl.*;
import org.etsi.uri.x01903.v14.*;
import org.etsi.uri.x01903.v14.impl.*;
import org.openxmlformats.schemas.drawingml.x2006.chart.*;
import org.openxmlformats.schemas.drawingml.x2006.chart.impl.*;
import org.openxmlformats.schemas.drawingml.x2006.chartDrawing.*;
import org.openxmlformats.schemas.drawingml.x2006.chartDrawing.impl.*;
import org.openxmlformats.schemas.drawingml.x2006.diagram.*;
import org.openxmlformats.schemas.drawingml.x2006.diagram.impl.*;
import org.openxmlformats.schemas.drawingml.x2006.lockedCanvas.*;
import org.openxmlformats.schemas.drawingml.x2006.lockedCanvas.impl.*;
import org.openxmlformats.schemas.drawingml.x2006.main.*;
import org.openxmlformats.schemas.drawingml.x2006.main.impl.*;
import org.openxmlformats.schemas.drawingml.x2006.picture.*;
import org.openxmlformats.schemas.drawingml.x2006.picture.impl.*;
import org.openxmlformats.schemas.drawingml.x2006.spreadsheetDrawing.*;
import org.openxmlformats.schemas.drawingml.x2006.spreadsheetDrawing.impl.*;
import org.openxmlformats.schemas.drawingml.x2006.wordprocessingDrawing.*;
import org.openxmlformats.schemas.drawingml.x2006.wordprocessingDrawing.impl.*;
import org.openxmlformats.schemas.officeDocument.x2006.bibliography.*;
import org.openxmlformats.schemas.officeDocument.x2006.bibliography.impl.*;
import org.openxmlformats.schemas.officeDocument.x2006.characteristics.*;
import org.openxmlformats.schemas.officeDocument.x2006.characteristics.impl.*;
import org.openxmlformats.schemas.officeDocument.x2006.customProperties.*;
import org.openxmlformats.schemas.officeDocument.x2006.customProperties.impl.*;
import org.openxmlformats.schemas.officeDocument.x2006.customXml.*;
import org.openxmlformats.schemas.officeDocument.x2006.customXml.impl.*;
import org.openxmlformats.schemas.officeDocument.x2006.docPropsVTypes.*;
import org.openxmlformats.schemas.officeDocument.x2006.docPropsVTypes.impl.*;
import org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.*;
import org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.impl.*;
import org.openxmlformats.schemas.officeDocument.x2006.math.*;
import org.openxmlformats.schemas.officeDocument.x2006.math.impl.*;
import org.openxmlformats.schemas.officeDocument.x2006.relationships.*;
import org.openxmlformats.schemas.officeDocument.x2006.relationships.impl.*;
import org.openxmlformats.schemas.officeDocument.x2006.sharedTypes.*;
import org.openxmlformats.schemas.officeDocument.x2006.sharedTypes.impl.*;
import org.openxmlformats.schemas.presentationml.x2006.main.*;
import org.openxmlformats.schemas.presentationml.x2006.main.impl.*;
import org.openxmlformats.schemas.schemaLibrary.x2006.main.*;
import org.openxmlformats.schemas.schemaLibrary.x2006.main.impl.*;
import org.openxmlformats.schemas.spreadsheetml.x2006.main.*;
import org.openxmlformats.schemas.spreadsheetml.x2006.main.impl.*;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.*;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.impl.*;
import org.openxmlformats.schemas.xpackage.x2006.digitalSignature.*;
import org.openxmlformats.schemas.xpackage.x2006.digitalSignature.impl.*;
import org.openxmlformats.schemas.xpackage.x2006.relationships.*;
import org.openxmlformats.schemas.xpackage.x2006.relationships.impl.*;
import org.w3.x2000.x09.xmldsig.*;
import org.w3.x2000.x09.xmldsig.impl.*;
import org.apache.xmlbeans.*;
import org.apache.xmlbeans.soap.*;
import org.apache.xmlbeans.xml.stream.*;
import org.apache.xmlbeans.xml.stream.events.*;
import org.apache.xmlbeans.metadata.system.sXMLSCHEMA.*;
import org.apache.xmlbeans.metadata.system.sXMLCONFIG.*;
import org.apache.xmlbeans.metadata.system.sXMLTOOLS.*;
import org.apache.xmlbeans.metadata.system.sXMLLANG.*;
import org.apache.xmlbeans.impl.regex.*;
import org.apache.xmlbeans.impl.soap.*;
import org.apache.xmlbeans.impl.store.*;
import org.apache.xmlbeans.impl.config.*;
import org.apache.xmlbeans.impl.common.*;
import org.apache.xmlbeans.impl.richParser.*;
import org.apache.xmlbeans.impl.values.*;
import org.apache.xmlbeans.impl.tool.*;
import org.apache.xmlbeans.impl.xsd2inst.*;
import org.apache.xmlbeans.impl.xpath.*;
import org.apache.xmlbeans.impl.xpath.saxon.*;
import org.apache.xmlbeans.impl.xpath.xmlbeans.*;
import org.apache.xmlbeans.impl.validator.*;
import org.apache.xmlbeans.impl.xb.xsdownload.*;
import org.apache.xmlbeans.impl.xb.xsdownload.impl.*;
import org.apache.xmlbeans.impl.xb.xsdschema.*;
import org.apache.xmlbeans.impl.xb.xsdschema.impl.*;
import org.apache.xmlbeans.impl.xb.substwsdl.*;
import org.apache.xmlbeans.impl.xb.substwsdl.impl.*;
import org.apache.xmlbeans.impl.xb.xmlconfig.*;
import org.apache.xmlbeans.impl.xb.xmlconfig.impl.*;
import org.apache.xmlbeans.impl.xb.ltgfmt.*;
import org.apache.xmlbeans.impl.xb.ltgfmt.impl.*;
import org.apache.xmlbeans.impl.xb.xmlschema.*;
import org.apache.xmlbeans.impl.xb.xmlschema.impl.*;
import org.apache.xmlbeans.impl.inst2xsd.*;
import org.apache.xmlbeans.impl.inst2xsd.util.*;
import org.apache.xmlbeans.impl.schema.*;
import org.apache.xmlbeans.impl.xpathgen.*;
import org.apache.xmlbeans.impl.util.*;
import org.apache.xmlbeans.impl.repackage.*;

import wblut.core.*;
import wblut.geom.*;
import wblut.hemesh.*;
import wblut.math.*;
import wblut.nurbs.*;
import wblut.processing.*;
import peasy.*;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import java.io.FileOutputStream;
import java.io.IOException;
import g4p_controls.*;
import org.quark.jasmine.*;
import java.awt.Font;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Simulador extends PApplet {











  // Fully qualified name to resolve ambiguity









float nC = 1e-6f; //Numero nC
float p = 1e-2f; //Escala distancia

final float f = 5 * 1e3f; // Escala del vector de fuerza 3d
final float f_ = 1e2f; // Escala del vector de fuerza en 2d

final float k = 8.99e9f;
final float Eo = 8.85e-12f;

float escala = 2;

int numTheta = 10;
int numPhi = 7;
float radio = 25;

int op = 1;
int opO = 0;

int index = 0;
float x_ = 770;
float y_ = 117;

int xi = -500;
int yi = 0;

ArrayList<Particula> nuevasParticulas = new ArrayList<Particula>();
ArrayList<Particula> eliminarParticulas = new ArrayList<Particula>();
ArrayList<Particula> particula = new ArrayList<>();
ArrayList<GButton> prop = new ArrayList<>();

Camara camara = new Camara();
VentanaS s = new VentanaS();
Objeto cable = new Objeto();
Objeto anillo = new Objeto();

ArrayList<Objeto> placa = new ArrayList<>();

static boolean e = false;
static boolean c = false;
static boolean v = false;
static boolean simulacion = false;

long tiempoI;
long tiempoF;
long tiempoT;

PVector mouse;
Colision m;
Colision malla;

WB_Render3D render;
HE_Mesh mesh;
HEC_Torus creator;

public void setup() {
  /* size commented out by preprocessor */;  // Inicializar la ventana en modo 3D
  render = new WB_Render3D(this);

  // Inicializar Jasmine
  Compile.init();
  createGUI();

  sliderCable.setVisible(false);
  propSimulacion.setVisible(false);
  guia1.setVisible(false);
  guia2.setVisible(false);
  propiedades.setVisible(false);

  /* smooth commented out by preprocessor */;

  // Agregar botón en la ventana de interfaz
  int size = 15;

  propElectrica.setFont(new Font("Arial", Font.PLAIN, size));
  propCampo.setFont(new Font("Arial", Font.PLAIN, size));
  propEstatico.setFont(new Font("Arial", Font.PLAIN, size));

  lblMasa.setFont(new Font("Arial", Font.PLAIN, size));
  propMasa.setFont(new Font("Arial", Font.PLAIN, size));
  lblMasaU.setFont(new Font("Arial", Font.PLAIN, size));

  lblPosX.setFont(new Font("Arial", Font.PLAIN, size));
  propPosX .setFont(new Font("Arial", Font.PLAIN, size));
  lblPosY.setFont(new Font("Arial", Font.PLAIN, size));
  propPosY.setFont(new Font("Arial", Font.PLAIN, size));
  lblPosU.setFont(new Font("Arial", Font.PLAIN, size));

  lblVelX.setFont(new Font("Arial", Font.PLAIN, size));
  propVelX.setFont(new Font("Arial", Font.PLAIN, size ));
  propVelX.setEnabled(false);
  lblVelY.setFont(new Font("Arial", Font.PLAIN, size));
  propVelY.setFont(new Font("Arial", Font.PLAIN, size));
  propVelY.setEnabled(false);
  lblVelU.setFont(new Font("Arial", Font.PLAIN, size));



  mouse = new PVector();
  malla = new Colision(new PVector(100, 100), 500, 500);

  cable = new Cable(500, 1, new PVector(0, 0, 0));
  placa.add(new Placa(1500, 1500, 1, new PVector(0, -500, 0)));
  placa.add(new Placa(1500, 1500, -1, new PVector(0, 500, 0)));
  anillo = new Anillo(300, 1, new PVector(0, 0, 0));


  Insertar();


  mesh = new HE_Mesh(creator);
}

public void draw() {
  customGUI();

  background(255);
  display3D();
}

public void display3D() {
  lights();  // Agregar luces para mejor visualización 3D
  camara.updateCamera();
  camara.drawWorld();

  switch(opO) {
  case 1:
    cable.Display();
    break;
  case 2:
    for (Objeto p : placa) p.Display();
    break;
  case 3:
    anillo.Display();
    break;
  }

  int y = 0;
  for (Particula p : particula) {
    p.Display();

    fill(0);
    text("particula " + p.i + " :", xi, yi + y);
    text("p = " + p.q, xi, yi + 20 + y);
    text("x: " + p.posE.x + ", y:" + - p.posE.y, xi, yi + 40 + y);
    text("Fueza Neta: ", xi, yi + 60 + y);
    text("Magnitud = " + p.fuerzaE.mag() + " N", xi, yi + 80 + y);
    text("Potencial = " + p.potencial + " V", xi, yi + 100 + y);
    y += 130;
  }

  if (!nuevasParticulas.isEmpty()) {
    particula.addAll(nuevasParticulas);
    nuevasParticulas.clear();
  }

  if (!eliminarParticulas.isEmpty()) {
    particula.removeAll(eliminarParticulas);
    eliminarParticulas.clear();

    index = 0;
    x_ = 770;
    y_ = 117;

    if (particula.size() == 0) return;

    for (int i = 0; i < particula.size(); i++) {
      Particula p = particula.get(i);
      index++;
      p.i = index;

      p.texto.moveTo(x_, y_);
      p.texto.setText(String.valueOf((int) (p.q / nC)));

      GButton botonProp = prop.get(i);
      botonProp.moveTo(x_ + 130, y_ + 3);

      y_ += 60;
    }
  }
}

public void Malla(PApplet a) {
}

public PVector campoTotal(PVector punto) {
  PVector campoTotal = new PVector(0, 0, 0);

  // Sumar campos de partículas
  for (Particula p : particula) {
    PVector campo = p.Campo(punto);
    campoTotal.add(campo);
  }

  //Sumar campo anillo
  if (opO == 3) {
    campoTotal.add(anillo.Campo(punto));
  }

  // Sumar campos de placas
  if (opO == 2) {
    for (Objeto p : placa) {
      PVector campo = p.Campo(punto);
      campoTotal.add(campo);
    }
  }

  // Sumar campo del cable
  if (opO == 1) {
    campoTotal.add(cable.Campo(punto));
  }

  return campoTotal;
}

public float calcularPotencial(PVector punto) {
  float voltaje = 0;

  /*
  if(opO == 2){
   for(Objeto p : placa) {
   voltaje += p.Potencial(punto);
   }
   }
   */

  for (Particula p : particula) {
    if (p.q != 0) voltaje += p.Potencial(punto);
  }

  return voltaje;
}


public void Mouse(PApplet a) {
  if (m == null) m = new Colision(mouse, 5, 5);

  mouse.x = a.mouseX;
  mouse.y = a.mouseY;
  m.pos = mouse;
}

public boolean Colision(Colision another) {
  return m.detectar(another);
}

public void customGUI() {
  tiempo.setText(String.valueOf(Tiempo()));

  if (propiedades.isVisible()) {
    lblPosU.setText("*" + p * 100 + " m");
    lblVelU.setText("*" + p * 100 + " m / s");
  }

  listEspacio.setEnabled(!propSimulacion.isVisible());

  switch(opO) {
    //Cable
  case 1:
    if (campo.isSelected()) {
      if (listDistribucion.getSelectedIndex() != 0) listDistribucion.setSelected(0);
      listDistribucion.setEnabled(false);
      campo.setEnabled(true);
      lblMin.setText("Carga");
      lblMax.setVisible(false);
      txtMax.setEnabled(false);
      txtMax.setVisible(false);
      txtMin.setEnabled(true);
      sliderCable.setVisible(true);
    } else {
      sliderCable.setVisible(true);
      listDistribucion.setEnabled(true);
      campo.setText("Constante");
      campo.setEnabled(true);
      lblMax.setText("Carga Maxima");
      lblMin.setText("Carga Minima");
      lblMax.setVisible(true);
      txtMax.setEnabled(true);
      txtMax.setVisible(true);
      txtMin.setEnabled(true);
    }
    break;
    //Placas
  case 2:
    listDistribucion.setEnabled(true);
    campo.setText("Infinito");
    campo.setEnabled(true);
    lblMin.setText("Carga");
    lblMax.setVisible(false);
    txtMax.setEnabled(false);
    txtMax.setVisible(false);
    txtMin.setEnabled(true);
    sliderCable.setVisible(false);
    break;
  default:
    listDistribucion.setEnabled(false);
    campo.setText("Constante");
    campo.setEnabled(false);
    lblMax.setText("Carga Maxima");
    lblMin.setText("Carga Minima");
    lblMax.setVisible(true);
    txtMax.setEnabled(false);
    txtMin.setEnabled(false);
    txtMax.setVisible(true);
    txtMin.setVisible(true);
    sliderCable.setVisible(false);
    break;
  }
}

public int colorCampo(float magnitudMinima, float magnitudCampo, float magnitudMaxima) {
  int colorInicio = color(255);
  int colorFinal = color(100);

  float logMin = log(magnitudMinima + 1); // Añadir 1 para evitar log(0)
  float logMax = log(magnitudMaxima + 1);
  float escala = map(log(magnitudCampo + 1), logMin, logMax, 0, 1);
  return lerpColor(colorInicio, colorFinal, escala);
}

int d = 25;

public void keyPressed() {
  
  switch(key) {
  case 'q':
    if (interfaz.isVisible()) {
      interfaz.setVisible(false);
    } else {
      interfaz.setVisible(true);
    }
    break;
  case 'x':
    d++;
    break;
  case 'z':
    if(d != 0) d--;
  }

  switch(keyCode) {
  case 32:
    if (particula.size() == 0) return;
    simulacion = simulacion ? false : true;

    Simulacion();
    break;
  }
}
class Camara {
  PVector cameraPosition, cameraTarget, cameraUp;
  float moveSpeed = 10;
  float angleY = 0, angleX = 0;  // Para controlar la rotación de la vista

  float paso = 27;
  float xMin = -500;
  float xMax = 500;
  float yMin = -500;
  float yMax = 500;
  float zMin = 0;
  float zMax = 0;

  Camara() {
    // Inicializar la posición de la cámara y el objetivo (hacia donde mira)
    cameraPosition = new PVector(0, 0, 200);  // Iniciar cámara en Z=200
    cameraTarget = new PVector(0, 0, 0);      // Mirando al origen
    cameraUp = new PVector(0, 1, 0);          // El "arriba" de la cámara es el eje Y
  }

  public void drawWorld() {
    // Dibujar una cuadrícula para tener referencia
    pushMatrix();
    translate(0, 0, 0);

    strokeWeight(2);
    stroke(0, 50);
    for (int i = -500; i <= 500; i += 100) {
      line(i, xMin, 0, i, xMax, 0);  // Líneas en X
      line(yMin, i, 0, yMax, i, 0);  // Líneas en y
    }

    strokeWeight(1);
    stroke(150, 50);
    for (int i = -500; i <= 500; i += 25) {
      line(i, xMin, 0, i, xMax, 0);  // Líneas en X
      line(yMin, i, 0, yMax, i, 0);  // Líneas en y
    }

    strokeWeight(2);

    //Eje x
    stroke(255, 0, 0);
    line(- 500, 0, 0, 500, 0, 0);
    
    //Eje y
    stroke(0, 255, 0);
    line(0, - 500, 0, 0, 500, 0);

    //Eje z
    stroke(0, 0, 255);
    line(0, 0, -500, 0, 0, 500);

    textSize(20);
    text("x", 500, 0, 0);
    text("y", 0, -500, 0);
    text("z", 0, 0, 500);
    popMatrix();

    if (c) dibujarCampo();
    if (v) dibujarEquipotenciales();
  }

  // Actualizar la posición y dirección de la cámara
  public void updateCamera() {
    // Control de rotación de la cámara con el ratón
    if (mousePressed) {
      angleY += (mouseX - pmouseX) * 0.005f;  // Rotar en eje Y
      angleX += (mouseY - pmouseY) * 0.005f;  // Rotar en eje X
    }

    // Crear el vector de dirección a partir de los ángulos de rotación
    PVector direction = new PVector(
      cos(angleY) * cos(angleX),
      sin(angleX),
      sin(angleY) * cos(angleX)
      );

    // Actualizar el objetivo de la cámara
    cameraTarget = PVector.add(cameraPosition, direction);

    // Configurar la cámara usando `camera()`
    camera(cameraPosition.x, cameraPosition.y, cameraPosition.z, // Posición de la cámara
      cameraTarget.x, cameraTarget.y, cameraTarget.z, // A dónde mira la cámara
      cameraUp.x, cameraUp.y, cameraUp.z);                   // El vector "arriba" de la cámara

    // Movimiento de la cámara con el teclado
    if (keyPressed) {
      switch(key) {
      case 'w':

        cameraPosition.add(PVector.mult(direction, moveSpeed));  // Avanzar
        break;
      case 's':
        cameraPosition.sub(PVector.mult(direction, moveSpeed));  // Retroceder
        break;
      case 'a':
        PVector left = direction.cross(cameraUp);  // Mover hacia la izquierda
        cameraPosition.sub(PVector.mult(left, moveSpeed));
        break;
      case 'd':
        PVector right = direction.cross(cameraUp);  // Mover hacia la derecha
        cameraPosition.add(PVector.mult(right, moveSpeed));
        break;
      }
    }
  }

  public void dibujarCampo() {
    float[] rango = estimarCampo();

    for (float x = xMin; x <= xMax; x += paso) {
      for (float y = yMin; y <= yMax; y += paso) {
        for (float z = zMin; z <= zMax; z += paso) {

          PVector punto = new PVector(x, y, z);
          curvaCampo(punto, rango);

          // Visualizar el campo en este punto
        }
      }
    }
  }

  public void curvaCampo(PVector punto, float[] rango) {
    PVector puntoActual = punto.copy();
    PVector campoTotal = new PVector(0, 0, 0);

    float cMin = rango[0];
    float cMax = rango[1];


    beginShape();
    
    for (int i = 0; i <= d; i ++) {
      campoTotal.set(0, 0, 0);

      campoTotal.add(campoTotal(puntoActual));

      int Color = colorCampo(cMin, campoTotal.mag(), cMax);
      
      stroke(Color, campoTotal.mag() * 0.05f);

      campoTotal.normalize();

      PVector puntoAnterior = puntoActual.copy();

      puntoActual.add(PVector.mult(campoTotal, 5));


      noFill();
      
      vertex(puntoAnterior.x, puntoAnterior.y, puntoAnterior.z);
    }
    endShape();
  }

  public float[] estimarCampo() {
    float magnitudMaxima = 0;
    float magnitudMinima = 0.001f;

    for (float x = xMin; x <= xMax; x += paso) {
      for (float y = yMin; y <= yMax; y += paso) {
        for (float z = zMin; z <= zMax; z += paso) {

          PVector punto = new PVector(x, y, z);
          PVector campoTotal = campoTotal(punto);
          float magnitudCampo = campoTotal.mag();

          if (magnitudCampo > magnitudMaxima) {
            magnitudMaxima = magnitudCampo;
          }
        }
      }
    }

    float[] rango = {magnitudMinima, magnitudMaxima};
    return rango;
  }

  public void dibujarEquipotenciales() {
    float potencialMin = -20000;
    float potencialMax = 20000;
    int numEquipotenciales = 15;
    float deltaPotencial = (potencialMax - potencialMin) / numEquipotenciales;

    float paso = 2.5f;
    int cols = (int)Math.ceil((xMax - xMin) / paso);
    int rows = (int)Math.ceil((yMax - yMin) / paso);
    float[][] potenciales = new float[cols + 1][rows + 1];

    // Calcular y almacenar los potenciales
    for (int i = 0; i <= cols; i++) {
      for (int j = 0; j <= rows; j++) {
        float x = xMin + i * paso;
        float y = yMin + j * paso;
        PVector punto = new PVector(x, y, 0);
        potenciales[i][j] = calcularPotencial(punto);
      }
    }

    // Para cada valor equipotencial
    for (int n = 0; n <= numEquipotenciales; n++) {
      float valorEquipotencial = potencialMin + n * deltaPotencial;
      stroke(colorPotencial(valorEquipotencial)); // Puedes variar el color según el potencial

      // Recorrer la rejilla y aplicar Marching Squares
      for (int i = 0; i < cols; i++) {
        for (int j = 0; j < rows; j++) {
          // Obtener los potenciales en los cuatro vértices de la celda
          float v1 = potenciales[i][j];         // Superior izquierdo
          float v2 = potenciales[i + 1][j];     // Superior derecho
          float v3 = potenciales[i + 1][j + 1]; // Inferior derecho
          float v4 = potenciales[i][j + 1];     // Inferior izquierdo

          // Determinar el índice del caso
          int caso = 0;
          if (v1 >= valorEquipotencial) caso |= 1;
          if (v2 >= valorEquipotencial) caso |= 2;
          if (v3 >= valorEquipotencial) caso |= 4;
          if (v4 >= valorEquipotencial) caso |= 8;

          float x0 = xMin + i * paso;
          float y0 = yMin + j * paso;

          float x1, y1, x2, y2;
          switch (caso) {
          case 0:
          case 15:
            break;
          case 1:
          case 14:
            // Línea entre el borde izquierdo y el borde superior
            x1 = x0;
            y1 = y0 + interpola(v1, v4, valorEquipotencial) * paso;
            x2 = x0 + interpola(v1, v2, valorEquipotencial) * paso;
            y2 = y0;
            line(x1, y1, x2, y2);
            break;

          case 2:
          case 13:
            x1 = x0 + interpola(v1, v2, valorEquipotencial) * paso;
            y1 = y0;
            x2 = x0;
            y2 = y0 + interpola(v2, v3, valorEquipotencial) * paso;
            line(x1, y1, x2, y2);
            break;
          case 3:
          case 12:
            x1 = x0;
            y1 = y0 + interpola(v1, v4, valorEquipotencial) * paso;
            x2 = x0;
            y2 = y0 + interpola(v2, v3, valorEquipotencial) * paso;
            line(x1, y1, x2, y2);
            break;
          case 4:
          case 11:
            x1 = x0;
            y1 = y0 + interpola(v1, v4, valorEquipotencial) * paso;
            x2 = x0 + interpola(v1, v2, valorEquipotencial) * paso;
            y2 = y0;
            line(x1, y1, x2, y2);
            break;
          case 5:
            x1 = x0;
            y1 = y0 + interpola(v1, v4, valorEquipotencial) * paso;
            x2 = x0 + interpola(v2, v3, valorEquipotencial) * paso;
            y2 = y0;
            line(x1, y1, x2, y2);

            x1 = x0;
            y1 = y0 + interpola(v2, v3, valorEquipotencial) * paso;
            x2 = x0 + interpola(v3, v4, valorEquipotencial) * paso;
            y2 = y0;
            line(x1, y1, x2, y2);
            break;
          case 10:
            x1 = x0 + interpola(v1, v2, valorEquipotencial) * paso;
            y1 = y0;
            x2 = x0;
            y2 = y0 + interpola(v1, v4, valorEquipotencial) * paso;
            line(x1, y1, x2, y2);

            x1 = x0;
            y1 = y0 + interpola(v2, v3, valorEquipotencial) * paso;
            x2 = x0 + interpola(v3, v4, valorEquipotencial) * paso;
            y2 = y0;
            line(x1, y1, x2, y2);
            break;
          case 6:
          case 9:
            x1 = x0 + interpola(v1, v2, valorEquipotencial) * paso;
            y1 = y0;
            x2 = x0 + interpola(v3, v4, valorEquipotencial) * paso;
            y2 = y0;
            line(x1, y1, x2, y2);
            break;
          case 7:
          case 8:
            x1 = x0;
            y1 = y0 + interpola(v1, v4, valorEquipotencial) * paso;
            x2 = x0 + interpola(v3, v4, valorEquipotencial) * paso;
            y2 = y0 + paso;
            line(x1, y1, x2, y2);
            break;
          }
        }
      }
    }
  }

  // Función para interpolar entre dos valores
  public float interpola(float val1, float val2, float valorEquipotencial) {
    if (val2 == val1) {
      return 0.5f;
    } else {
      return (valorEquipotencial - val1) / (val2 - val1);
    }
  }

  public void dibujarPotencial() {
    float paso = 20;

    for (float x = xMin; x <= xMax; x += paso) {
      for (float y = yMin; y <= yMax; y += paso) {
        PVector punto = new PVector(x, y, 0); // Considerando z = 0


        float voltaje = calcularPotencial(punto);

        // Mapear el voltaje a un color
        int Color = colorPotencial(voltaje);

        // Dibujar un punto o cuadrado con el color correspondiente
        stroke(Color);
        point(x, y);
      }
    }
  }

  public int colorPotencial(float voltaje) {
    // Define los valores mínimo y máximo del potencial
    float voltajeMin = -100; // Ajusta según tu simulación
    float voltajeMax = 100;  // Ajusta según tu simulación

    // Mapear el voltaje a un valor entre 0 y 255
    float valorColor = map(voltaje, voltajeMin, voltajeMax, 0, 255);
    valorColor = constrain(valorColor, 0, 255);

    // Retornar un color basado en el valor mapeado
    return color(255 - valorColor, 0, valorColor); // De rojo a azul
  }
}
class Colision {
  PVector pos;
  float width;
  float height;
  
  Colision(PVector pos, float width, float height){
    this.pos = pos;
    this.width = width;
    this.height = height;
  }
  
  Colision(PVector pos, float width, float height, float r){
    this.pos = pos;
    this.pos.x = pos.x - r;
    this.pos.y = pos.y - r;
    this.width = width;
    this.height = height;
  }
  
  public boolean detectar(Colision another) {
    return (pos.x < another.pos.x + another.width &&
      pos.x + width > another.pos.x &&
      pos.y < another.pos.y + another.height &&
      pos.y + height > another.pos.y);
  }
  
}
public void archivoExcel() {
  try {
    // Crear un nuevo libro de trabajo Excel (XSSFWorkbook es para archivos .xlsx)
    Workbook workbook = new XSSFWorkbook();

    // Crear una hoja dentro del libro

    for (Particula p : particula) {
      
      
      Sheet hoja = workbook.createSheet("Particula #" + p.i);

      // Crear una fila en la hoja
      Row fila = hoja.createRow(0);
      fila.createCell(0).setCellValue("Carga");
      fila.createCell(1).setCellValue(p.q);

      fila = hoja.createRow(1);
      fila.createCell(0).setCellValue("Masa");
      fila.createCell(1).setCellValue(p.masa);

      fila = hoja.createRow(3);
      fila.createCell(0).setCellValue("Tiempo");
      fila.createCell(1).setCellValue("PosX");
      fila.createCell(2).setCellValue("PosY");
      fila.createCell(3).setCellValue("VelX");
      fila.createCell(4).setCellValue("VelY");
      fila.createCell(5).setCellValue("Velocidad");
      fila.createCell(6).setCellValue("AcelX");
      fila.createCell(7).setCellValue("ACelY");
      fila.createCell(8).setCellValue("Aceleracion");
      fila.createCell(9).setCellValue("FuerzaX");
      fila.createCell(10).setCellValue("FuerzaY");
      fila.createCell(11).setCellValue("Fuerza");
      fila.createCell(12).setCellValue("Campo");
      
      for(int i = 0; i < p.datoTiempo.size(); i++){
        Row row = hoja.createRow(4 + i);
        row.createCell(0).setCellValue(p.datoTiempo.get(i)); // Time
        row.createCell(1).setCellValue(p.datoPos.get(i).x); // PosX
        row.createCell(2).setCellValue(p.datoPos.get(i).y); // PosY
        row.createCell(3).setCellValue(p.datoVel.get(i).x); // VelX
        row.createCell(4).setCellValue(p.datoVel.get(i).y); // VelY
        row.createCell(5).setCellValue(p.datoVel.get(i).mag()); // Velocity magnitude
        row.createCell(6).setCellValue(p.datoAc.get(i).x); // AcelX
        row.createCell(7).setCellValue(p.datoAc.get(i).y); // AcelY
        row.createCell(8).setCellValue(p.datoAc.get(i).mag()); // Acceleration magnitude
        row.createCell(9).setCellValue(p.datoFuerza.get(i).x); // FuerzaX
        row.createCell(10).setCellValue(p.datoFuerza.get(i).y); // FuerzaY
        row.createCell(11).setCellValue(p.datoFuerza.get(i).mag()); // Force magnitude
        row.createCell(12).setCellValue(p.datoCampo.get(i).mag()); // Campo magnitude
      }
      
      
    }

    // Intentar guardar el archivo Excel en el sistema
    FileOutputStream fileOut = new FileOutputStream(dataPath("simulacion.xlsx"));
    workbook.write(fileOut);
    fileOut.close();
    workbook.close();
    println("Archivo Excel creado exitosamente.");
  }
  catch (IOException e) {
    e.printStackTrace();
    println("Error al crear el archivo Excel.");
  }
}
public void botonPropiedades_click(GButton source, GEvent event) {
  if (event == GEvent.CLICKED) {
    if (!propiedades.isVisible()) propiedades.setVisible(true);
  }
}

public void prop_click(GButton source, GEvent event) {
  for (int i = 0; i < prop.size(); i++) {
    Particula p = particula.get(i);
    if (source == prop.get(i) && !propiedades.isVisible()) {

      propiedades.setVisible(true);
      p.selected = true;

      propElectrica.setSelected(p.fuerza);
      propCampo.setSelected(p.campo);
      propEstatico.setSelected(p.estatico);

      propMasa.setText(String.valueOf((int) p.masa));
      propPosX.setText(String.valueOf(p.posE.x / (this.p * 100)));
      propPosY.setText(String.valueOf(- p.posE.y / (this.p * 100)));
      propVelX.setText(String.valueOf(p.vel.x));
      propVelY.setText(String.valueOf(- p.vel.y));

      if (p.estatico) {
        propVelX.setEnabled(false);
        propVelY.setEnabled(false);
      }

      if (simulacion == true) {
        propEstatico.setEnabled(false);
        if (!p.estatico) propPosX.setEnabled(false);
        if (!p.estatico) propPosY.setEnabled(false);
      } else {
        propEstatico.setEnabled(true);
      }
    }
  }
}

public void Insertar() {
  botonSimulacion.setVisible(true);
  botonAgregar.setVisible(true);
  if (opO == 0) checkPotencial.setVisible(true);
  checkElectrica.setVisible(true);
  checkCampo.setVisible(true);
}

public void Simulacion() {

  if (simulacion) {
    tiempoT = 0;
    tiempoI = millis();
    botonSimulacion.setText("Pausar");
  } else {
    tiempoF = millis();
    tiempoT += (tiempoF - tiempoI);
    botonSimulacion.setText("Iniciar");

    archivoExcel();

    for (Particula p : particula) {
      p.vel.set(0, 0, 0);
      p.estatico = true;
    }
  }
}

public float Tiempo() {
  if (simulacion) {
    // Si la simulación está corriendo, calcular el tiempo actual también
    return (tiempoT + (millis() - tiempoI)) / 1000.0f;
  } else {
    // Si está pausada, devolver el tiempo total acumulado
    return tiempoT / 1000.0f;
  }
}
class Objeto {
  protected boolean inf;

  protected float qMax;
  protected float qMin;
  protected int tipo;

  protected PVector pos;


  protected float largo;
  protected float ancho;
  protected float altura;
  protected float dCarga;
  protected float q;

  protected float pasos = 50;
  protected float pasosA;
  protected float pasosL;

  protected boolean campo = true;

  Objeto() {
  }

  Objeto(float l, float a, float h, float q) {
    this.largo = l;
    this.ancho = a;
    this.altura = h;
    this.q = q * nC;
  }

  public void Display() {
  }

  public PVector Campo(PVector pos, PVector punto) {
    return null;
  }

  public PVector Campo(PVector punto) {
    return null;
  }

  public float Potencial(PVector pos, PVector punto) {
    return 0.0f;
  }

  public float Potencial(PVector punto) {
    return 0.0f;
  }
}


class Cable extends Objeto {
  int numLados = 20;
  float radio = 5;

  Cable(float l, float q, PVector pos) {
    this.pos = pos;
    this.largo = l;
    this.q = q * nC;
    this.qMax = q * nC;
    this.qMin = q * nC;
    this.tipo = 0;
    this.inf = true;
  }

  Cable(float l, float qMax, float qMin, PVector pos) {
    this.pos = pos;
    this.largo = l;
    this.qMax = qMax * nC;
    this.qMin = qMin * nC;
    this.tipo = 1;
    this.inf = false;
  }

  @Override public 
    void Display() {
    pushMatrix();
    translate(pos.x, pos.y, pos.z);
    cable(radio, largo, numLados);
    popMatrix();

    if (campo & !c) dibujarCampo();
  }

  @Override public 
    PVector Campo(PVector pos, PVector punto) {

    PVector direccion = PVector.sub(punto, pos);
    float distancia = direccion.mag() * p;

    if (distancia < 1) distancia = 1;

    direccion.normalize();

    float carga = carga(pos.x);

    float magnitudCampo = (k * carga) / (distancia * distancia);

    return direccion.mult(magnitudCampo);
  }

  @Override public 
    PVector Campo(PVector punto) {
    PVector campoTotal = new PVector(0, 0, 0);
    PVector tempCampo = new PVector();

    float lMedia = largo / 2;

    for (float x = - lMedia; x <= lMedia; x += pasos) {
      tempCampo.set(x, cable.pos.y, cable.pos.z);
      PVector campo = cable.Campo(tempCampo, punto);
      campoTotal.add(campo);
    }

    return campoTotal;
  }

  public float carga(float x) {
    float xNorma = x / (largo / 2);

    switch(tipo) {
    case 1:
      return map(xNorma, -1, 1, qMin, qMax); //Carga Lineal
    case 2:
      return qMax * (xNorma * xNorma); //Carga cuadratica
    case 3:
      return qMax * sin(TWO_PI * xNorma); //Carga sinuoidal
    }

    return q; //Carga constante
  }

  public void dibujarCampo() {
    for (float x = - largo / 2; x <= largo / 2; x += pasos) {
      boolean cargaNegativa = carga(x) < 0;

      for (int i = 0; i < numTheta; i++) {
        float theta = map(i, 0, numTheta, 0, TWO_PI); // Ángulo theta de 0 a 2π

        for (int j = 0; j < numPhi; j++) {
          float phi = map(j, 0, numPhi, 0, PI); // Ángulo phi de 0 a π

          float y = radio * sin(phi) * sin(theta);
          float z = radio * cos(phi);

          curvaCampo(new PVector(x, y, z).add(pos), cargaNegativa);
        }
      }
    }
  }

  public void curvaCampo(PVector puntoInicial, boolean cargaNegativa) {
    PVector puntoActual = puntoInicial.copy();
    PVector campoTotal = new PVector(0, 0, 0);

    beginShape();
    for (int i = 0; i <= 25; i ++) {

      campoTotal.add(campoTotal(puntoActual));

      campoTotal.normalize();

      if (cargaNegativa) {
        campoTotal.mult(-1);
      }

      PVector puntoAnterior = puntoActual.copy();

      // Avanzar en la dirección del campo eléctrico
      puntoActual.add(PVector.mult(campoTotal, 5)); // Paso ajustable (5 píxeles en este caso)

      // Dibujar la línea entre el punto anterior y el actual
      noFill();
      stroke(150, 70);
      vertex(puntoAnterior.x, puntoAnterior.y, puntoAnterior.z);
    }

    endShape();
  }

  public void cable(float r, float l, int lados) {
    float anguloIncremento = TWO_PI / lados;
    noStroke();
    fill(150);
    // Dibujamos la tapa izquierda del cilindro
    beginShape(TRIANGLE_FAN);
    vertex(-l / 2, pos.y, pos.z);  // Centro de la tapa izquierda
    for (float angulo = 0; angulo <= TWO_PI + anguloIncremento; angulo += anguloIncremento) {
      vertex(-l / 2, r * cos(angulo), r * sin(angulo));
    }
    endShape();

    // Dibujamos la tapa derecha del cilindro
    beginShape(TRIANGLE_FAN);
    vertex(l / 2, pos.y, pos.z);  // Centro de la tapa derecha
    for (float angulo = 0; angulo <= TWO_PI + anguloIncremento; angulo += anguloIncremento) {
      vertex(l / 2, r * cos(angulo), r * sin(angulo));
    }
    endShape();

    // Dibujamos las paredes laterales del cilindro
    beginShape(QUAD_STRIP);
    for (float angulo = 0; angulo <= TWO_PI + anguloIncremento; angulo += anguloIncremento) {
      float y = r * cos(angulo);
      float z = r * sin(angulo);
      vertex(-l / 2, y + pos.y, z + pos.z);  // Punto en la tapa izquierda
      vertex(l / 2, y + pos.y, z + pos.z);   // Punto en la tapa derecha
    }
    endShape();
  }
}

class Placa extends Objeto {
  float pasos_ = 4.5f;

  float pasosL;
  float pasosA;

  Placa(float l, float a, float q, PVector pos) {
    this.pos = pos;

    this.largo = l;
    this.ancho = a;
    this.altura = 1;

    this.q = q * nC;
    this.qMax = q * nC;
    this.qMin = q * nC;
    this.dCarga = q  / (a * l);

    this.tipo = 0;
    this.pasos = 144;
    this.pasosL = largo / pasos_;
    this.pasosA = ancho / pasos_;

    this.inf = false;
  }

  @Override public 
    void Display() {
    if(q != 0)placa(ancho, largo);

    if (campo & !c) dibujarCampo();
  }

  @Override public 
    PVector Campo(PVector pos, PVector punto) {
    PVector direccion = PVector.sub(punto, pos);
    float distancia = direccion.mag() * p;

    if (distancia < 1) distancia = 1;

    direccion.normalize();

    float magnitudCampo;
    if (inf) {
      magnitudCampo = dCarga / (2 * Eo);

      if (punto.y > pos.y) {
        direccion = new PVector(0, 1, 0); // Campo apunta hacia arriba
      } else if (punto.y < pos.y) {
        direccion = new PVector(0, -1, 0); // Campo apunta hacia abajo
      } else {
        direccion = new PVector(0, 0, 0); // Campo es cero en el plano de la placa
      }
    } else {
      magnitudCampo = (k * q) / (distancia * distancia);
    }

    return direccion.mult(magnitudCampo);
  }

  @Override public 
    PVector Campo(PVector punto) {
    PVector campoTotal = new PVector(0, 0, 0);
    PVector tempCampo = new PVector();

    for (float x = - ancho / 2; x <= ancho / 2; x += pasos) {
      for (float z = - largo/ 2; z <= largo/ 2; z += pasos) {
        tempCampo.set(x, pos.y, z);
        PVector campo = Campo(tempCampo, punto);
        campoTotal.add(campo);
      }
    }
    return campoTotal;
  }

  public void dibujarCampo() {
    boolean cargaNegativa = q < 0;
    float[] rango = camara.estimarCampo();

    for (float x = - ancho / 2; x <= (ancho / 2); x += pasosA) {

      for (float y = -100; y <= 100; y += pasos) {

        for (float z = - largo / 2; z <= (largo/ 2); z += pasosL) {

          curvaCampo(new PVector(x, y, z).add(pos), cargaNegativa, rango);
        }
      }
    }
  }

  public void curvaCampo(PVector puntoInicial, boolean cargaNegativa, float[] rango) {
    PVector puntoActual = puntoInicial.copy();
    PVector campoTotal = new PVector(0, 100, 0);
    
    float cMin = rango[0];
    float cMax = rango[1];
    
    beginShape();
    for (int i = 0; i <= 150; i ++) {
      campoTotal.set(0, 0, 0);

      campoTotal.add(campoTotal(puntoActual));
      
      int Color = colorCampo(cMin, campoTotal.mag(), cMax);
      
      stroke(Color);

      campoTotal.normalize();

      if (cargaNegativa) {
        campoTotal.mult(-1);
      }

      PVector puntoAnterior = puntoActual.copy();

      // Avanzar en la dirección del campo eléctrico
      puntoActual.add(PVector.mult(campoTotal, 5)); // Paso ajustable (5 píxeles en este caso)

      // Dibujar la línea entre el punto anterior y el actual
      noFill();
      
      vertex(puntoAnterior.x, puntoAnterior.y, puntoAnterior.z);
    }

    endShape();
  }
  @Override public 
    float Potencial(PVector punto) {
    float voltaje = 0;
    PVector tempPos = new PVector();

    for (float x = - ancho / 2; x <= ancho / 2; x += pasosA) {
      tempPos.set(x, 0, 0).add(pos);
      voltaje += Potencial(tempPos, punto);
    }

    return voltaje;
  }

  @Override public 
    float Potencial(PVector pos, PVector punto) {
    float distancia = PVector.dist(punto, pos);
    float dq = dCarga * pasosA * pasosL;

    if (distancia == 0) {
      return 0; // O manejarlo según corresponda
    }

    return (k * dq) / distancia;
  }

  public void placa(float ancho, float largo) {

    pushMatrix();
    noStroke();
    fill(240);
    translate(pos.x, pos.y, pos.z);
    box(ancho, altura, largo);
    popMatrix();
  }
}

class Anillo extends Objeto {
  float R;
  float r;
  float pasos = 5;

  Anillo(float R, float q, PVector pos) {
    this. R = R;
    this.pos = pos;
    this.q = q * nC;
    creator =  new HEC_Torus(5, R, 64, 32);
  }
  
  @Override public 
    void Display() {
    
    if (campo & !c) dibujarCampo();  
      
    pushMatrix();
    noStroke();
    fill(150);
    translate(pos.x, pos.y, pos.z);
    rotateY(PI / 2);
    render.drawFaces(mesh);
    render.drawEdges(mesh);
    popMatrix();
  }

  @Override public 
    PVector Campo(PVector pos, PVector punto) {
    PVector direccion = PVector.sub(punto, pos);
    float distancia = direccion.mag() * p;

    if (distancia < 1) distancia = 1;

    direccion.normalize();

    float magnitudCampo = (k * q) / (distancia * distancia);

    return direccion.mult(magnitudCampo);
  }

  @Override public 
    PVector Campo(PVector punto) {
    PVector campoTotal = new PVector(0, 0, 0);
    PVector tempCampo = new PVector();

    for (int i = 0; i < pasos; i++) {
      float theta = map(i, 0, pasos, 0, TWO_PI); 

      float y = R * cos(theta);  
      float z = R * sin(theta);  
      
      tempCampo.set(anillo.pos.x, y, z);


      campoTotal.add(anillo.Campo(tempCampo, punto));
    }

    return campoTotal;
  }

  public void dibujarCampo() {
    boolean cargaNegativa = q < 0;
    
    for (int i = 0; i < numTheta; i++) {
      float theta = map(i, 0, numTheta, 0, TWO_PI); 

      float y = radio * cos(theta);  
      float z = radio * sin(theta);  
      
      curvaCampo(new PVector(0, y, z).add(pos), cargaNegativa);
    }

  }

  public void curvaCampo(PVector puntoInicial, boolean cargaNegativa) {
    PVector puntoActual = puntoInicial.copy();
    PVector campoTotal = new PVector(0, 100, 0);

    beginShape();
    for (int i = 0; i <= 100; i ++) {
      campoTotal.set(0, 0, 0);

      campoTotal.add(campoTotal(puntoActual));

      campoTotal.normalize();

      if (cargaNegativa) {
        campoTotal.mult(-1);
      }

      PVector puntoAnterior = puntoActual.copy();

      // Avanzar en la dirección del campo eléctrico
      puntoActual.add(PVector.mult(campoTotal, 5)); // Paso ajustable (5 píxeles en este caso)

      // Dibujar la línea entre el punto anterior y el actual
      noFill();
      stroke(150, 70);
      vertex(puntoAnterior.x, puntoAnterior.y, puntoAnterior.z);
    }

    endShape();
  }




  
}
class Particula {
  Colision colision;
  Vector vector;

  boolean arrastrando;
  boolean selected;
  boolean campo;
  boolean fuerza;
  boolean estatico;

  PVector pos; //Posicion en 3d
  PVector pos_; //Posicion en 2d
  PVector norma; //Referencia de la posicion 3d en 2d
  PVector offset;
  PVector posE;

  PVector fuerzaE;
  PVector vel;
  PVector ac;

  float q;
  float masa;
  float potencial;


  int c;

  int r;
  int i;

  ArrayList<Float> datoTiempo = new ArrayList<>();
  ArrayList<PVector> datoPos = new ArrayList<>();
  ArrayList<PVector> datoVel = new ArrayList<>();
  ArrayList<PVector> datoAc = new ArrayList<>();
  ArrayList<PVector> datoFuerza = new ArrayList<>();
  ArrayList<PVector> datoCampo = new ArrayList<>();


  GTextField texto;

  Particula() {
  }

  Particula(float x, float y, float z, float q, float masa) {

    index++;
    this.r = 350;

    pos = new PVector(x, y, z);
    pos_ = new PVector(pos.x - 7.5f + r, pos.y - 7.5f + r);
    norma = new PVector(x, y);

    vel = new PVector(0, 0, 0);
    ac = new PVector(0, 0, 0);

    this.q = q * nC;
    fuerzaE = new PVector(0, 0);
    this.masa = masa;

    arrastrando = false;
    campo = true;
    fuerza = true;
    estatico = true;

    colision = new Colision(pos_, 20, 20);

    this.i = index;
    vector = new Vector(this);


    texto = new GTextField(interfaz, x_, y_, 50, 30);
    texto.setText(String.valueOf((int) q));
    texto.setFont(new Font("Arial", Font.PLAIN, 24));

    prop.add(new GButton(interfaz, x_ + 130, y_ + 3, 30, 30, "P"));

    y_ += 60;
  }

  public void Display() {
    // Dibujar la Particula 1 en 3D (roja)
    pushStyle();
    noStroke();
    fill(c);
    pushMatrix();
    translate(pos.x, pos.y, pos.z);
    sphere(5);  // Dibujar la esfera que representa la Particula 1
    popMatrix();
    popStyle();

    vector.Display();
    if (!Simulador.c & campo & q != 0) vector.dibujarCampo();
    if (!estatico & simulacion) Movimiento();
    Potencial();

    posE = PVector.sub(pos, new PVector(0, 0, 0)).mult(p);
  }

  public void Display(PApplet a) {

    a.noStroke();
    a.fill(c);
    a.circle(pos_.x + 7.5f, pos_.y + 7.5f, 15);

    //a.rect(colision.pos.x, colision.pos.y, colision.width, colision.height);
  }

  public boolean Colision(Colision another) {
    return colision.detectar(another);
  }

  public PVector Campo(PVector punto) {
    PVector direccion = PVector.sub(punto, this.pos);
    float distancia = direccion.mag() * p;

    if (distancia < 1 * p) distancia = 1;

    direccion.normalize();

    float magnitudCampo = (k * this.q) / (distancia * distancia);
    
    return direccion.mult(magnitudCampo);
  }

  public void Movimiento() {
    PVector campoTotal = new PVector(0, 0, 0);

    campoTotal.add(campoTotal(pos));

    actualizar();

    if (simulacion) {

      if (Tiempo() * 1000 % 5 == 0) {
        datoPos.add(pos.copy());
        datoFuerza.add(fuerzaE.copy());
        datoAc.add(ac.copy());
        datoTiempo.add(Tiempo());
        datoVel.add(vel.copy());
        datoCampo.add(campoTotal(pos).copy());
      }
    }

    if ((pos.x > 550|| pos.x < -550 || pos.y > 550|| pos.y < -550)) {
      simulacion = false;
      estatico = true;

      Simulacion();

      propEstatico.setSelected(true);
      ac = new PVector(0, 0, 0);
      vel = new PVector(0, 0, 0);
      pos.x = pos_.x - r;
      pos.y = pos_.y - r;
      pos.z = 0;

      datoPos.clear();
      datoFuerza.clear();
      datoAc.clear();
      datoTiempo.clear();
      datoVel.clear();
    }
  }
  
  public void actualizar() {
    ac = PVector.div(fuerzaE, masa);
    vel.add(ac);
    pos.add(vel);
  }

  public float Potencial(PVector punto) {
    float distancia = PVector.dist(pos, punto) * p;

    if (distancia == 0) {
      return Float.POSITIVE_INFINITY; // O manejarlo según corresponda
    }

    return (k * q) / distancia;
  }

  public void Potencial() {
    float potencial = 0;

    for (Particula p : particula) {
      if (this != p) {
        potencial += p.Potencial(this.pos);
      }
    }


    this.potencial = potencial;
  }
}
class Vector {
  Particula p;
  float r = 7.5f;

  float radioCono = 2;
  float alturaCono = 5;

  Vector(Particula p) {
    this.p = p;
  }

  public void Display() {
    // Dibujar el vector de fuerza en 3D
    vectorFuerza();
    
    if(e & p.fuerza & p.estatico) return;
    pushMatrix();
    stroke(0);
    strokeWeight(2);
    line(p.pos.x, p.pos.y, p.pos.z,
      p.pos.x + p.fuerzaE.x * f, // Escalar para visualización
      p.pos.y + p.fuerzaE.y * f,
      p.pos.z + p.fuerzaE.z * f);
    popMatrix();
    
  }

  public void Display(PApplet a) {
    a.stroke(0);
    a.strokeWeight(2);
    a.line(p.pos_.x + r, p.pos_.y + r,
      p.pos_.x + (p.fuerzaE.x * f_) + r,
      p.pos_.y + (p.fuerzaE.y * f_) + r);
  }

  public void vectorFuerza() {       
    PVector campoTotal = new PVector(0, 0, 0);

      campoTotal.add(campoTotal(p.pos));
      
      p.fuerzaE = campoTotal.mult(p.q);
    
  }

  public void dibujarCampo() {
    boolean cargaNegativa = p.q < 0;
    float[] rango = camara.estimarCampo();

    for (int i = 0; i < numTheta; i++) {
      float theta = map(i, 0, numTheta, 0, TWO_PI); // Ángulo theta de 0 a 2π

      for (int j = 0; j < numPhi; j++) {
        float phi = map(j, 0, numPhi, 0, PI); // Ángulo phi de 0 a π

        float x = radio * sin(phi) * cos(theta);
        float y = radio * sin(phi) * sin(theta);
        float z = radio * cos(phi);

        curvaCampo(new PVector(x, y, z).add(p.pos), cargaNegativa, rango);
      }
    }
  }

  public void curvaCampo(PVector puntoInicial, boolean cargaNegativa, float[] rango) {
    PVector puntoActual = puntoInicial.copy();
    PVector campoTotal = new PVector(0, 0, 0);    
    
    float cMin = rango[0];
    float cMax = rango[1];
    
    beginShape();
    for (int i = 0; i <= 100; i ++) {
      campoTotal.set(0, 0, 0);

      campoTotal.add(campoTotal(puntoActual));
      
      int Color = colorCampo(cMin, campoTotal.mag(), cMax);
      
      stroke(Color, campoTotal.mag() * 0.05f);

      campoTotal.normalize();

      if (cargaNegativa) {
        campoTotal.mult(-1);
      }

      PVector puntoAnterior = puntoActual.copy();

      // Avanzar en la dirección del campo eléctrico
      puntoActual.add(PVector.mult(campoTotal, 5)); // Paso ajustable (5 píxeles en este caso)

      // Dibujar la línea entre el punto anterior y el actual
      noFill();
      
      vertex(puntoAnterior.x, puntoAnterior.y, puntoAnterior.z);
    }
    endShape();
  }
}
class VentanaS {
  public void Inicio(PApplet a) {
    a.fill(0);
    a.textSize(16);
    a.text("Interfaz 2D", a.width / 2, 30);
  }

  public void Insertar(PApplet a) {
    int xi = 100;
    int yi = 100;

    //Malla
    a.stroke(0);
    a.strokeWeight(2);
    a.fill(255);
    a.rect(xi, yi, 500, 500);

    a.stroke(150, 50);
    a.fill(0);
    a.strokeWeight(1);
    int j = -10;
    for (int i = 0; i <= 500; i += 25) {
      a.line(xi, yi + i, xi + 500, yi + i);
      a.line(xi + i, yi, xi + i, yi + 500);


      a.textSize(12);
      a.text(j, xi + i - 4, yi + 520);
      j++;
    }

    a.strokeWeight(2);
    a.stroke(0, 50);
    for (int i = 0; i <= 500; i += 50) {
      a.line(xi, yi + i, xi + 500, yi + i);
      a.line(xi + i, yi, xi + i, yi + 500);
    }

    a.strokeWeight(2);
    a.stroke(0, 255, 0);
    a.line(xi + 250, yi, xi + 250, yi + 500);

    a.stroke(255, 0, 0);
    a.line(xi, yi + 250, xi + 500, yi + 250);

    a.textSize(20);
    a.text("y", xi + 246, yi - 4);
    a.text("x", xi + 504, yi + 254);
    
    a.textSize(20);
    a.text(Tiempo(), xi + 440, yi + 490);

    //Particulas
    int xf = 650;
    int yf = 100;
    a.stroke(0);
    a.strokeWeight(2);
    a.fill(255);
    a.rect(xf, yf, 300, 500, 10);

    int y_ = 0;
    for (Particula p : particula) {
      a.fill(51, 50);
      a.noStroke();
      a.rect(xf + 10, yf + 10 + y_, 280, 50, 10);

      a.fill(0);
      a.text("Particula " + p.i, xf + 20, yf + 40 + y_);
      a.text(nC + "C", xf + 180, yf + 40 + y_);

      if (!p.texto.getText().trim().isEmpty()) p.q = Float.parseFloat(p.texto.getText().trim()) * nC;


      y_ += 60;

      p.Display(a);

      if (p.arrastrando & Colision(malla)) {
        p.pos_.set((a.mouseX - p.offset.x), (a.mouseY - p.offset.y));
        p.norma.set((a.mouseX - p.offset.x), (a.mouseY - p.offset.y));

        p.pos.set(p.norma.x * escala, p.norma.y * escala);
        p.colision.pos.set(p.norma.x - 7.5f + p.r, p.norma.y - 7.5f + p.r);

        p.c = color(0, 255, 0);
      } else {
        p.c = p.q > 0 ? color(0) : color(255, 0, 0);
      }

      if (!p.selected) {
        p.c = p.q > 0 ? color(0) : color(255, 0, 0);
      } else {
        p.c = color(0, 255, 0);
      }
    }
  }
}
/* =========================================================
 * ====                   WARNING                        ===
 * =========================================================
 * The code in this tab has been generated from the GUI form
 * designer and care should be taken when editing this file.
 * Only add/edit code inside the event handlers i.e. only
 * use lines between the matching comment tags. e.g.

 void myBtnEvents(GButton button) { //_CODE_:button1:12356:
     // It is safe to enter your event code here  
 } //_CODE_:button1:12356:
 
 * Do not rename this tab!
 * =========================================================
 */

synchronized public void draw2D(PApplet appc, GWinData data) { //_CODE_:interfaz:662211:
  appc.background(230);

  try {
    Mouse(appc);
  }
  catch(Exception e) {
  }
  s.Insertar(appc);
} //_CODE_:interfaz:662211:

synchronized public void arrastrarMouse_dragged(PApplet appc, GWinData data, MouseEvent mevent) { //_CODE_:interfaz:451853:
  if (mevent.getAction() == MouseEvent.PRESS) {
    // Detectar si el ratón hizo clic sobre el círculo
    for (Particula p : particula) {
      if (Colision(p.colision)) {

        p.arrastrando = true;
        p.offset =  new PVector(appc.mouseX - p.norma.x, appc.mouseY - p.norma.y);
        break;
      }
    }
  }

  if (mevent.getAction() == MouseEvent.RELEASE) {
    // Detener el arrastre cuando se suelta el ratón
    for (Particula p : particula) {
      p.arrastrando = false;
    }
  }
} //_CODE_:interfaz:451853:

public void botonAgregar_click(GButton source, GEvent event) { //_CODE_:botonAgregar:241399:
  if (event == GEvent.CLICKED) {
    if (particula.size() > 7) return;

    nuevasParticulas.add(new Particula(0, 0, 0, 1, 1));
    prop.get(index - 1).addEventHandler(this, "prop_click");
  }
} //_CODE_:botonAgregar:241399:

public void botonSimulacion_click(GButton source, GEvent event) { //_CODE_:botonSimulacion:538595:
  if (event == GEvent.CLICKED) {

    if (particula.size() == 0) return;

    simulacion = simulacion ? false : true;

    Simulacion();
  }
} //_CODE_:botonSimulacion:538595:

public void checkPotencial_click(GCheckbox source, GEvent event) { //_CODE_:checkPotencial:453597:
  v = source.isSelected() ? true : false;
} //_CODE_:checkPotencial:453597:

public void checkElectrica_click(GCheckbox source, GEvent event) { //_CODE_:checkElectrica:537409:
  e = source.isSelected() ? true : false;
} //_CODE_:checkElectrica:537409:

public void checkCampo_click(GCheckbox source, GEvent event) { //_CODE_:checkCampo:531909:
  c = source.isSelected() ? true : false;
} //_CODE_:checkCampo:531909:

public void slider1_change1(GSlider source, GEvent event) { //_CODE_:sliderCable:620390:
  cable.largo = source.getValueF();
} //_CODE_:sliderCable:620390:

public void propiedades_click(GButton source, GEvent event) { //_CODE_:botonPropiedades:845455:
  propSimulacion.setVisible(true);

  switch(opO) {
  case 1:


    campo.setSelected(cable.inf);
    if (campo.isSelected()) {
      txtMin.setText(String.valueOf(cable.q / nC));
    } else {
      txtMin.setText(String.valueOf(cable.qMin / nC));
      txtMax.setText(String.valueOf(cable.qMax / nC));
    }
    break;
  case 2:
    int i = 0;
    for (Objeto p : placa) {
      i++;
      listDistribucion.addItem("Placa " + i);
    }

    listDistribucion.removeItem(0);
    listDistribucion.removeItem(0);
    listDistribucion.removeItem(0);
    listDistribucion.removeItem(0);

    campo.setSelected(placa.get(0).inf);
    txtMin.setText(String.valueOf(placa.get(0).q / nC));
    break;
  default:
    listDistribucion.setSelected(0);
    campo.setSelected(true);
    txtMin.setText("-");
    txtMax.setText("-");
    break;
  }
} //_CODE_:botonPropiedades:845455:

public void listEspacio_select(GDropList source, GEvent event) { //_CODE_:listEspacio:607491:
  opO = source.getSelectedIndex();

  for (int i = 0; i < particula.size(); i++) {
    eliminarParticulas.add(particula.get(i));

    particula.get(i).texto.setVisible(false);
    particula.get(i).texto.dispose();

    prop.get(i).setVisible(false);
    prop.get(i).dispose();
  }
  prop.clear();
} //_CODE_:listEspacio:607491:

synchronized public void drawPropiedades(PApplet appc, GWinData data) { //_CODE_:propiedades:214121:
  appc.background(230);

  for (Particula p : particula) {
    if (p.selected) {

      if (p.arrastrando) {
        propPosX.setText(String.valueOf(p.posE.x / (this.p * 100)));
        propPosY.setText(String.valueOf(- p.posE.y / (this.p * 100)));
      }

      if (!p.estatico & simulacion) {
        propPosX.setText(String.valueOf(p.posE.x / (this.p * 100)));
        propPosY.setText(String.valueOf(- p.posE.y / (this.p * 100)));

        propVelX.setText(String.valueOf(p.vel.x));
        propVelY.setText(String.valueOf(- p.vel.y));
      }
    }
  }
} //_CODE_:propiedades:214121:

public void botonAplicar_click(GButton source, GEvent event) { //_CODE_:botonAplicar:521210:
  if (event != GEvent.CLICKED) return;
  for (Particula p : particula) {
    if (p.selected) {

      if (!propMasa.getText().trim().isEmpty()) {
        float masa = Float.parseFloat(propMasa.getText().trim());
        p.masa = masa <= 1 ? p.masa : masa;
      }


      if (!propPosX.getText().trim().isEmpty() & !propPosY.getText().trim().isEmpty()) {
        float posX = Float.parseFloat(propPosX.getText().trim()) * (100);
        float posY = - Float.parseFloat(propPosY.getText().trim()) * (100);

        p.pos.set(posX, posY);

        p.norma.set(posX / 2, posY / 2);
        p.pos_.set(p.norma.x + p.r - 7.5f, p.norma.y + p.r - 7.5f);
      }

      if (!propVelX.getText().trim().isEmpty() & !propVelY.getText().trim().isEmpty()) {
        float velX = Float.parseFloat(propVelX.getText().trim());
        float velY = - Float.parseFloat(propVelY.getText().trim());

        p.vel.x = velX;
        p.vel.y = velY;
      }

      propiedades.setVisible(false);
      p.selected = false;
    }
  }
} //_CODE_:botonAplicar:521210:

public void botonEliminar_click(GButton source, GEvent event) { //_CODE_:botonEliminar:486075:
  if (event != GEvent.CLICKED) return;

  for (int i = 0; i < particula.size(); i++) {
    if (particula.get(i).selected) {
      eliminarParticulas.add(particula.get(i));

      particula.get(i).texto.setVisible(false);
      particula.get(i).texto.dispose();

      prop.get(i).setVisible(false);
      prop.get(i).dispose();

      prop.remove(i);
      i--;

      break;
    }
  }
  propiedades.setVisible(false);
} //_CODE_:botonEliminar:486075:

public void propElectrica_click(GCheckbox source, GEvent event) { //_CODE_:propElectrica:911119:
  for (Particula p : particula) {
    if (p.selected) p.fuerza = source.isSelected() ? true : false;
  }
} //_CODE_:propElectrica:911119:

public void propCampo_click(GCheckbox source, GEvent event) { //_CODE_:propCampo:828506:
  for (Particula p : particula) {
    if (p.selected) p.campo = source.isSelected() ? true : false;
  }
} //_CODE_:propCampo:828506:

public void propEstatico_click(GCheckbox source, GEvent event) { //_CODE_:propEstatico:243267:
  for (Particula p : particula) {
    if (p.selected) {

      p.estatico = source.isSelected() ? true : false;

      if (!p.estatico) {
        propVelX.setEnabled(true);
        propVelY.setEnabled(true);
      } else {
        propVelX.setText("0.0");
        propVelX.setText("0.0");
        propVelX.setEnabled(false);
        propVelY.setEnabled(false);
      }
    }
  }
} //_CODE_:propEstatico:243267:

public void propMasa_change(GTextField source, GEvent event) { //_CODE_:propMasa:619178:
} //_CODE_:propMasa:619178:

public void propPosX_change(GTextField source, GEvent event) { //_CODE_:propPosX:381789:
} //_CODE_:propPosX:381789:

public void propPosY_change(GTextField source, GEvent event) { //_CODE_:propPosY:961826:
} //_CODE_:propPosY:961826:

public void propVelX_change(GTextField source, GEvent event) { //_CODE_:propVelX:214877:
} //_CODE_:propVelX:214877:

public void propVelY_change(GTextField source, GEvent event) { //_CODE_:propVelY:566350:
} //_CODE_:propVelY:566350:

synchronized public void drawSimulacion(PApplet appc, GWinData data) { //_CODE_:propSimulacion:895098:
  appc.background(230);
} //_CODE_:propSimulacion:895098:

public void botonAplicar_click1(GButton source, GEvent event) { //_CODE_:butonAplicar1:458806:
  propSimulacion.setVisible(false);

  switch(escalaDistancia.getSelectedIndex()) {
  case 0:
    p = 1e-1f; //10 m
    break;
  case 1:
    p = 1e-2f; //1 m
    break;
  case 2:
    p = 1e-3f; //0.1 m
    break;
  }

  switch(escalaCarga.getSelectedIndex()) {
  case 0:
    nC = 1e-6f;
    break;
  case 1:
    nC = 1e-3f;
    break;
  case 2:
    nC = 1;
    break;
  }

  switch(opO) {
  case 1:
    cable.inf = campo.isSelected();

    if (campo.isSelected()) {
      cable.q = Float.parseFloat(txtMin.getText()) * nC;
    } else {
      cable.tipo = listDistribucion.getSelectedIndex();

      cable.qMin = Float.parseFloat(txtMin.getText()) * nC;
      cable.qMax = Float.parseFloat(txtMax.getText()) * nC;
    }
    break;
  case 2:
    listDistribucion.addItem("Constante");
    listDistribucion.addItem("Lineal");
    listDistribucion.addItem("Cuadratica");
    listDistribucion.addItem("Sinuidal");

    listDistribucion.removeItem(0);
    listDistribucion.removeItem(0);
    break;
  default:
    break;
  }
} //_CODE_:butonAplicar1:458806:

public void distancia_click(GDropList source, GEvent event) { //_CODE_:escalaDistancia:767099:
} //_CODE_:escalaDistancia:767099:

public void carga_click(GDropList source, GEvent event) { //_CODE_:escalaCarga:846924:
} //_CODE_:escalaCarga:846924:

public void slider1_change2(GSlider source, GEvent event) { //_CODE_:sliderVector:815539:
  println("slider1 - GSlider >> GEvent." + event + " @ " + millis());
} //_CODE_:sliderVector:815539:

public void distribucion_click(GDropList source, GEvent event) { //_CODE_:listDistribucion:485310:
  switch(opO) {
  case 2:
    switch(listDistribucion.getSelectedIndex()) {
    case 0:
      campo.setSelected(placa.get(0).inf);
      txtMin.setText(String.valueOf(placa.get(0).q / nC));
      break;
    case 1:
      campo.setSelected(placa.get(1).inf);
      txtMin.setText(String.valueOf(placa.get(1).q / nC));
      break;
    }
    break;
  }
} //_CODE_:listDistribucion:485310:

public void textMin_change(GTextField source, GEvent event) { //_CODE_:txtMin:247087:
  if(opO == 2) placa.get(listDistribucion.getSelectedIndex()).q = Float.parseFloat(txtMin.getText()) / nC;
} //_CODE_:txtMin:247087:

public void textMax_change(GTextField source, GEvent event) { //_CODE_:txtMax:397608:

} //_CODE_:txtMax:397608:

public void checkCampo_clicked(GCheckbox source, GEvent event) { //_CODE_:campo:432574:
  switch(opO) {
  case 1:
    if (source.isSelected()) {
      txtMin.setText(String.valueOf(cable.q / nC));
    } else {
      txtMin.setText(String.valueOf(cable.qMin / nC));
      txtMax.setText(String.valueOf(cable.qMax / nC));
    }
    break;
  case 2:
    
    switch(listDistribucion.getSelectedIndex()){
    case 0:
      placa.get(0).inf = campo.isSelected();
      break;
    case 1:
      placa.get(1).inf = campo.isSelected();
      break;
    }
    break;
  }
} //_CODE_:campo:432574:



// Create all the GUI controls. 
// autogenerated do not edit
public void createGUI(){
  G4P.messagesEnabled(false);
  G4P.setGlobalColorScheme(GCScheme.BLUE_SCHEME);
  G4P.setMouseOverEnabled(false);
  surface.setTitle("Sketch Window");
  tiempo = new GLabel(this, 1333, 905, 122, 44);
  tiempo.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
  tiempo.setText("My label");
  tiempo.setOpaque(false);
  interfaz = GWindow.getWindow(this, "Interface", 0, 0, 1050, 850, JAVA2D);
  interfaz.noLoop();
  interfaz.setActionOnClose(G4P.KEEP_OPEN);
  interfaz.addDrawHandler(this, "draw2D");
  interfaz.addMouseHandler(this, "arrastrarMouse_dragged");
  botonAgregar = new GButton(interfaz, 800, 650, 150, 30);
  botonAgregar.setText("Agregar");
  botonAgregar.addEventHandler(this, "botonAgregar_click");
  botonSimulacion = new GButton(interfaz, 100, 700, 150, 30);
  botonSimulacion.setText("Iniciar");
  botonSimulacion.addEventHandler(this, "botonSimulacion_click");
  checkPotencial = new GCheckbox(interfaz, 350, 680, 150, 30);
  checkPotencial.setIconAlign(GAlign.LEFT, GAlign.MIDDLE);
  checkPotencial.setText("Lineas Equipotenciales");
  checkPotencial.setOpaque(false);
  checkPotencial.addEventHandler(this, "checkPotencial_click");
  checkElectrica = new GCheckbox(interfaz, 350, 720, 150, 30);
  checkElectrica.setIconAlign(GAlign.LEFT, GAlign.MIDDLE);
  checkElectrica.setText("Fuerzas Electricas");
  checkElectrica.setOpaque(false);
  checkElectrica.addEventHandler(this, "checkElectrica_click");
  checkCampo = new GCheckbox(interfaz, 350, 640, 150, 30);
  checkCampo.setIconAlign(GAlign.LEFT, GAlign.MIDDLE);
  checkCampo.setText("Campo Electrico");
  checkCampo.setOpaque(false);
  checkCampo.addEventHandler(this, "checkCampo_click");
  sliderCable = new GSlider(interfaz, 650, 700, 300, 60, 15.0f);
  sliderCable.setShowValue(true);
  sliderCable.setShowLimits(true);
  sliderCable.setLimits(500.0f, 250.0f, 1500.0f);
  sliderCable.setShowTicks(true);
  sliderCable.setNumberFormat(G4P.DECIMAL, 2);
  sliderCable.setOpaque(false);
  sliderCable.addEventHandler(this, "slider1_change1");
  botonPropiedades = new GButton(interfaz, 100, 650, 150, 30);
  botonPropiedades.setText("Propiedades de Simulacion");
  botonPropiedades.addEventHandler(this, "propiedades_click");
  listEspacio = new GDropList(interfaz, 100, 50, 90, 100, 4, 10);
  listEspacio.setItems(loadStrings("list_607491"), 0);
  listEspacio.addEventHandler(this, "listEspacio_select");
  guia1 = new GLabel(interfaz, 100, 100, 500, 500);
  guia1.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
  guia1.setOpaque(true);
  guia2 = new GLabel(interfaz, 650, 100, 300, 500);
  guia2.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
  guia2.setOpaque(true);
  lblTitulo = new GLabel(interfaz, 228, 15, 245, 62);
  lblTitulo.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
  lblTitulo.setText("Simulador de Interacciones entre Cargas Electricas");
  lblTitulo.setOpaque(false);
  lblParticula = new GLabel(interfaz, 743, 29, 138, 53);
  lblParticula.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
  lblParticula.setText("Particulas");
  lblParticula.setOpaque(false);
  propiedades = GWindow.getWindow(this, "Propiedades", 0, 0, 500, 300, JAVA2D);
  propiedades.noLoop();
  propiedades.setActionOnClose(G4P.KEEP_OPEN);
  propiedades.addDrawHandler(this, "drawPropiedades");
  botonAplicar = new GButton(propiedades, 350, 250, 100, 30);
  botonAplicar.setText("Aplicar");
  botonAplicar.addEventHandler(this, "botonAplicar_click");
  botonEliminar = new GButton(propiedades, 50, 250, 100, 30);
  botonEliminar.setText("Eliminar");
  botonEliminar.addEventHandler(this, "botonEliminar_click");
  propElectrica = new GCheckbox(propiedades, 50, 40, 120, 30);
  propElectrica.setIconAlign(GAlign.LEFT, GAlign.MIDDLE);
  propElectrica.setText("Fuerzas electricas");
  propElectrica.setOpaque(false);
  propElectrica.addEventHandler(this, "propElectrica_click");
  propCampo = new GCheckbox(propiedades, 50, 80, 120, 30);
  propCampo.setIconAlign(GAlign.LEFT, GAlign.MIDDLE);
  propCampo.setText("Campo electrico");
  propCampo.setOpaque(false);
  propCampo.addEventHandler(this, "propCampo_click");
  propEstatico = new GCheckbox(propiedades, 50, 120, 120, 30);
  propEstatico.setIconAlign(GAlign.LEFT, GAlign.MIDDLE);
  propEstatico.setText("Estatico");
  propEstatico.setOpaque(false);
  propEstatico.addEventHandler(this, "propEstatico_click");
  lblMasa = new GLabel(propiedades, 210, 40, 50, 30);
  lblMasa.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
  lblMasa.setText("Masa");
  lblMasa.setOpaque(false);
  propMasa = new GTextField(propiedades, 270, 40, 30, 30, G4P.SCROLLBARS_NONE);
  propMasa.setText("0");
  propMasa.setOpaque(true);
  propMasa.addEventHandler(this, "propMasa_change");
  lblMasaU = new GLabel(propiedades, 310, 40, 50, 30);
  lblMasaU.setText("kg");
  lblMasaU.setOpaque(false);
  lblPosX = new GLabel(propiedades, 210, 80, 50, 30);
  lblPosX.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
  lblPosX.setText("Pos X");
  lblPosX.setOpaque(false);
  propPosX = new GTextField(propiedades, 265, 80, 40, 30, G4P.SCROLLBARS_NONE);
  propPosX.setText("0");
  propPosX.setOpaque(true);
  propPosX.addEventHandler(this, "propPosX_change");
  lblPosY = new GLabel(propiedades, 310, 80, 50, 30);
  lblPosY.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
  lblPosY.setText("Pos Y");
  lblPosY.setOpaque(false);
  propPosY = new GTextField(propiedades, 365, 80, 40, 30, G4P.SCROLLBARS_NONE);
  propPosY.setText("0");
  propPosY.setOpaque(true);
  propPosY.addEventHandler(this, "propPosY_change");
  lblPosU = new GLabel(propiedades, 410, 80, 70, 30);
  lblPosU.setText("text");
  lblPosU.setOpaque(false);
  lblVelX = new GLabel(propiedades, 210, 120, 50, 30);
  lblVelX.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
  lblVelX.setText("Vel X");
  lblVelX.setOpaque(false);
  propVelX = new GTextField(propiedades, 265, 120, 40, 30, G4P.SCROLLBARS_NONE);
  propVelX.setText("0");
  propVelX.setOpaque(true);
  propVelX.addEventHandler(this, "propVelX_change");
  lblVelY = new GLabel(propiedades, 310, 120, 50, 30);
  lblVelY.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
  lblVelY.setText("VelY");
  lblVelY.setOpaque(false);
  propVelY = new GTextField(propiedades, 365, 120, 40, 30, G4P.SCROLLBARS_NONE);
  propVelY.setText("0");
  propVelY.setOpaque(true);
  propVelY.addEventHandler(this, "propVelY_change");
  lblVelU = new GLabel(propiedades, 410, 120, 80, 30);
  lblVelU.setText("text");
  lblVelU.setLocalColorScheme(GCScheme.CENTER);
  lblVelU.setOpaque(false);
  propSimulacion = GWindow.getWindow(this, "Propiedades Simulacion", 0, 0, 500, 260, JAVA2D);
  propSimulacion.noLoop();
  propSimulacion.setActionOnClose(G4P.KEEP_OPEN);
  propSimulacion.addDrawHandler(this, "drawSimulacion");
  butonAplicar1 = new GButton(propSimulacion, 360, 200, 100, 30);
  butonAplicar1.setText("Aplicar");
  butonAplicar1.addEventHandler(this, "botonAplicar_click1");
  escalaDistancia = new GDropList(propSimulacion, 30, 30, 90, 80, 3, 10);
  escalaDistancia.setItems(loadStrings("list_767099"), 1);
  escalaDistancia.addEventHandler(this, "distancia_click");
  escalaCarga = new GDropList(propSimulacion, 130, 30, 90, 80, 3, 10);
  escalaCarga.setItems(loadStrings("list_846924"), 0);
  escalaCarga.addEventHandler(this, "carga_click");
  sliderVector = new GSlider(propSimulacion, 30, 150, 150, 40, 15.0f);
  sliderVector.setLimits(0.5f, 0.0f, 1.0f);
  sliderVector.setNumberFormat(G4P.DECIMAL, 2);
  sliderVector.setOpaque(false);
  sliderVector.addEventHandler(this, "slider1_change2");
  lblVector = new GLabel(propSimulacion, 30, 110, 100, 30);
  lblVector.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
  lblVector.setText("Tamaño Vector");
  lblVector.setOpaque(false);
  listDistribucion = new GDropList(propSimulacion, 370, 30, 90, 100, 4, 10);
  listDistribucion.setItems(loadStrings("list_485310"), 0);
  listDistribucion.addEventHandler(this, "distribucion_click");
  lblMin = new GLabel(propSimulacion, 251, 101, 80, 30);
  lblMin.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
  lblMin.setText("Carga Minima");
  lblMin.setOpaque(false);
  txtMin = new GTextField(propSimulacion, 350, 100, 120, 30, G4P.SCROLLBARS_NONE);
  txtMin.setOpaque(true);
  txtMin.addEventHandler(this, "textMin_change");
  txtMax = new GTextField(propSimulacion, 350, 150, 120, 30, G4P.SCROLLBARS_NONE);
  txtMax.setOpaque(true);
  txtMax.addEventHandler(this, "textMax_change");
  lblMax = new GLabel(propSimulacion, 250, 150, 80, 30);
  lblMax.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
  lblMax.setText("Carga Maxima");
  lblMax.setOpaque(false);
  campo = new GCheckbox(propSimulacion, 250, 30, 100, 20);
  campo.setIconAlign(GAlign.LEFT, GAlign.MIDDLE);
  campo.setText("Constante");
  campo.setOpaque(false);
  campo.addEventHandler(this, "checkCampo_clicked");
  interfaz.loop();
  propiedades.loop();
  propSimulacion.loop();
}

// Variable declarations 
// autogenerated do not edit
GLabel tiempo; 
GWindow interfaz;
GButton botonAgregar; 
GButton botonSimulacion; 
GCheckbox checkPotencial; 
GCheckbox checkElectrica; 
GCheckbox checkCampo; 
GSlider sliderCable; 
GButton botonPropiedades; 
GDropList listEspacio; 
GLabel guia1; 
GLabel guia2; 
GLabel lblTitulo; 
GLabel lblParticula; 
GWindow propiedades;
GButton botonAplicar; 
GButton botonEliminar; 
GCheckbox propElectrica; 
GCheckbox propCampo; 
GCheckbox propEstatico; 
GLabel lblMasa; 
GTextField propMasa; 
GLabel lblMasaU; 
GLabel lblPosX; 
GTextField propPosX; 
GLabel lblPosY; 
GTextField propPosY; 
GLabel lblPosU; 
GLabel lblVelX; 
GTextField propVelX; 
GLabel lblVelY; 
GTextField propVelY; 
GLabel lblVelU; 
GWindow propSimulacion;
GButton butonAplicar1; 
GDropList escalaDistancia; 
GDropList escalaCarga; 
GSlider sliderVector; 
GLabel lblVector; 
GDropList listDistribucion; 
GLabel lblMin; 
GTextField txtMin; 
GTextField txtMax; 
GLabel lblMax; 
GCheckbox campo; 


  public void settings() { size(1500, 1000, P3D);
smooth(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "--full-screen", "--bgcolor=#666666", "--stop-color=#cccccc", "Simulador" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
